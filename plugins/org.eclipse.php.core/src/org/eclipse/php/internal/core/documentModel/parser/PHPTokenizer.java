/* The following code was generated by JFlex 1.4.1 on 17.04.14 16:37 */

/*******************************************************************************
 * Copyright (c) 2006 Zend Corporation and IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Zend and IBM - Initial implementation
 *******************************************************************************/
/*nlsXXX*/
package org.eclipse.php.internal.core.documentModel.parser;

import java.io.CharArrayReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.resources.IProject;
import org.eclipse.php.internal.core.PHPVersion;
import org.eclipse.php.internal.core.documentModel.parser.regions.PhpScriptRegion;
import org.eclipse.php.internal.core.project.ProjectOptions;
import org.eclipse.wst.sse.core.internal.ltk.parser.BlockMarker;
import org.eclipse.wst.sse.core.internal.ltk.parser.BlockTokenizer;
import org.eclipse.wst.sse.core.internal.provisional.text.ITextRegion;
import org.eclipse.wst.sse.core.internal.provisional.text.ITextRegionList;
import org.eclipse.wst.sse.core.internal.util.Debug;
import org.eclipse.wst.sse.core.utils.StringUtils;
import org.eclipse.wst.xml.core.internal.Logger;
import org.eclipse.wst.xml.core.internal.parser.ContextRegionContainer;
import org.eclipse.wst.xml.core.internal.parser.IntStack;
import org.eclipse.wst.xml.core.internal.parser.regions.XMLParserRegionFactory;
import org.eclipse.wst.xml.core.internal.regions.DOMRegionContext;

/**
 * This class is a scanner generated by <a href="http://www.jflex.de/">JFlex</a>
 * 1.4.1 on 17.04.14 16:37 from the specification file
 * <tt>PHPTokenizer.jflex</tt>
 */
public class PHPTokenizer implements BlockTokenizer, PHPRegionContext,
		DOMRegionContext {

	/** This character denotes the end of file */
	public static final int YYEOF = -1;

	/** initial size of the lookahead buffer */
	private static final int ZZ_BUFFERSIZE = 16384;

	/** lexical states */
	public static final int ST_XML_COMMENT_END = 4;
	public static final int ST_BLOCK_TAG_SCAN = 30;
	public static final int ST_DHTML_ATTRIBUTE_VALUE = 14;
	public static final int ST_XML_PI_ATTRIBUTE_NAME = 8;
	public static final int ST_DHTML_TAG_CLOSE = 15;
	public static final int ST_XML_ATTRIBUTE_VALUE_DQUOTED = 33;
	public static final int ST_DHTML_EQUALS = 13;
	public static final int ST_XML_PI_ATTRIBUTE_VALUE = 10;
	public static final int ST_XML_ATTRIBUTE_VALUE = 19;
	public static final int ST_XML_ATTRIBUTE_VALUE_SQUOTED = 32;
	public static final int ST_XML_ATTRIBUTE_NAME = 17;
	public static final int ST_XML_EQUALS = 18;
	public static final int YYINITIAL = 0;
	public static final int ST_XML_DOCTYPE_ID_SYSTEM = 25;
	public static final int ST_XML_ELEMENT_DECLARATION = 26;
	public static final int ST_XML_DECLARATION_CLOSE = 21;
	public static final int ST_XML_DOCTYPE_DECLARATION = 22;
	public static final int ST_CDATA_END = 2;
	public static final int ST_PI_WS = 6;
	public static final int ST_CDATA_TEXT = 1;
	public static final int ST_XML_ELEMENT_DECLARATION_CONTENT = 27;
	public static final int ST_XML_ATTLIST_DECLARATION = 28;
	public static final int ST_XML_PI_EQUALS = 9;
	public static final int ST_XML_ATTLIST_DECLARATION_CONTENT = 29;
	public static final int ST_XML_DOCTYPE_ID_PUBLIC = 24;
	public static final int ST_DHTML_ATTRIBUTE_NAME = 12;
	public static final int ST_PHP_CONTENT = 31;
	public static final int ST_ABORT_EMBEDDED = 15;
	public static final int ST_XML_DOCTYPE_EXTERNAL_ID = 23;
	public static final int ST_PI_CONTENT = 7;
	public static final int ST_BLOCK_TAG_INTERNAL_SCAN = 15;
	public static final int ST_PI = 5;
	public static final int ST_XML_DECLARATION = 20;
	public static final int ST_XML_TAG_NAME = 16;
	public static final int ST_XML_PI_TAG_CLOSE = 11;
	public static final int ST_XML_COMMENT = 3;

	/**
	 * Translates characters to character classes
	 */
	private static final String ZZ_CMAP_PACKED = "\11\0\1\6\1\23\2\0\1\15\22\0\1\15\1\22\1\12\1\56"
			+ "\1\71\1\20\1\13\1\14\1\17\1\17\1\17\1\17\1\17\1\10"
			+ "\1\7\1\3\12\16\1\11\1\62\1\1\1\5\1\2\1\4\1\17"
			+ "\1\27\1\63\1\25\1\26\1\45\1\60\1\34\1\70\1\40\1\34"
			+ "\1\34\1\53\1\54\1\42\1\41\1\44\1\34\1\36\1\57\1\30"
			+ "\1\61\2\34\1\52\1\43\1\34\1\24\1\0\1\21\1\0\1\11"
			+ "\1\0\1\47\1\63\1\64\1\50\1\35\1\60\1\34\1\67\1\40"
			+ "\2\34\1\33\1\32\1\42\1\41\1\44\1\34\1\36\1\37\1\46"
			+ "\1\61\1\34\1\34\1\31\1\51\1\34\1\72\1\55\72\0\1\66"
			+ "\10\0\27\65\1\0\37\65\1\0\72\65\2\0\13\65\2\0\10\65"
			+ "\1\0\65\65\1\0\104\65\11\0\44\65\3\0\2\65\4\0\36\65"
			+ "\70\0\131\65\22\0\7\65\16\0\2\66\56\0\106\66\32\0\2\66"
			+ "\44\0\1\65\1\66\3\65\1\0\1\65\1\0\24\65\1\0\54\65"
			+ "\1\0\7\65\3\0\1\65\1\0\1\65\1\0\1\65\1\0\1\65"
			+ "\1\0\22\65\15\0\14\65\1\0\102\65\1\0\14\65\1\0\44\65"
			+ "\1\0\4\66\11\0\65\65\2\0\2\65\2\0\2\65\3\0\34\65"
			+ "\2\0\10\65\2\0\2\65\67\0\46\65\2\0\1\65\7\0\46\65"
			+ "\12\0\21\66\1\0\27\66\1\0\3\66\1\0\1\66\1\0\2\66"
			+ "\1\0\1\66\13\0\33\65\5\0\3\65\56\0\32\65\5\0\1\66"
			+ "\12\65\10\66\15\0\12\66\6\0\1\66\107\65\2\0\5\65\1\0"
			+ "\17\65\1\0\4\65\1\0\1\65\17\66\2\65\2\66\1\0\4\66"
			+ "\2\0\12\66\u0207\0\3\66\1\0\65\65\2\0\1\66\1\65\20\66"
			+ "\3\0\4\66\3\0\12\65\2\66\2\0\12\66\21\0\3\66\1\0"
			+ "\10\65\2\0\2\65\2\0\26\65\1\0\7\65\1\0\1\65\3\0"
			+ "\4\65\2\0\1\66\1\0\7\66\2\0\2\66\2\0\3\66\11\0"
			+ "\1\66\4\0\2\65\1\0\3\65\2\66\2\0\12\66\2\65\20\0"
			+ "\1\66\2\0\6\65\4\0\2\65\2\0\26\65\1\0\7\65\1\0"
			+ "\2\65\1\0\2\65\1\0\2\65\2\0\1\66\1\0\5\66\4\0"
			+ "\2\66\2\0\3\66\13\0\4\65\1\0\1\65\7\0\12\66\2\66"
			+ "\3\65\14\0\3\66\1\0\7\65\1\0\1\65\1\0\3\65\1\0"
			+ "\26\65\1\0\7\65\1\0\2\65\1\0\5\65\2\0\1\66\1\65"
			+ "\10\66\1\0\3\66\1\0\3\66\22\0\1\65\5\0\12\66\21\0"
			+ "\3\66\1\0\10\65\2\0\2\65\2\0\26\65\1\0\7\65\1\0"
			+ "\2\65\2\0\4\65\2\0\1\66\1\65\6\66\3\0\2\66\2\0"
			+ "\3\66\10\0\2\66\4\0\2\65\1\0\3\65\4\0\12\66\22\0"
			+ "\2\66\1\0\6\65\3\0\3\65\1\0\4\65\3\0\2\65\1\0"
			+ "\1\65\1\0\2\65\3\0\2\65\3\0\3\65\3\0\10\65\1\0"
			+ "\3\65\4\0\5\66\3\0\3\66\1\0\4\66\11\0\1\66\17\0"
			+ "\11\66\21\0\3\66\1\0\10\65\1\0\3\65\1\0\27\65\1\0"
			+ "\12\65\1\0\5\65\4\0\7\66\1\0\3\66\1\0\4\66\7\0"
			+ "\2\66\11\0\2\65\4\0\12\66\22\0\2\66\1\0\10\65\1\0"
			+ "\3\65\1\0\27\65\1\0\12\65\1\0\5\65\4\0\7\66\1\0"
			+ "\3\66\1\0\4\66\7\0\2\66\7\0\1\65\1\0\2\65\4\0"
			+ "\12\66\22\0\2\66\1\0\10\65\1\0\3\65\1\0\27\65\1\0"
			+ "\20\65\4\0\6\66\2\0\3\66\1\0\4\66\11\0\1\66\10\0"
			+ "\2\65\4\0\12\66\221\0\56\65\1\0\1\65\1\66\2\65\7\66"
			+ "\5\0\6\65\1\66\10\66\1\0\12\66\47\0\2\65\1\0\1\65"
			+ "\2\0\2\65\1\0\1\65\2\0\1\65\6\0\4\65\1\0\7\65"
			+ "\1\0\3\65\1\0\1\65\1\0\1\65\2\0\2\65\1\0\2\65"
			+ "\1\0\1\65\1\66\2\65\6\66\1\0\2\66\1\65\2\0\5\65"
			+ "\1\0\1\66\1\0\6\66\2\0\12\66\76\0\2\66\6\0\12\66"
			+ "\13\0\1\66\1\0\1\66\1\0\1\66\4\0\2\66\10\65\1\0"
			+ "\41\65\7\0\24\66\1\0\6\66\4\0\6\66\1\0\1\66\1\0"
			+ "\25\66\3\0\7\66\1\0\1\66\346\0\46\65\12\0\47\65\11\0"
			+ "\1\65\1\0\2\65\1\0\3\65\1\0\1\65\1\0\2\65\1\0"
			+ "\5\65\51\0\1\65\1\0\1\65\1\0\1\65\13\0\1\65\1\0"
			+ "\1\65\1\0\1\65\3\0\2\65\3\0\1\65\5\0\3\65\1\0"
			+ "\1\65\1\0\1\65\1\0\1\65\1\0\1\65\3\0\2\65\3\0"
			+ "\2\65\1\0\1\65\50\0\1\65\11\0\1\65\2\0\1\65\2\0"
			+ "\2\65\7\0\2\65\1\0\1\65\1\0\7\65\50\0\1\65\4\0"
			+ "\1\65\10\0\1\65\u0c06\0\234\65\4\0\132\65\6\0\26\65\2\0"
			+ "\6\65\2\0\46\65\2\0\6\65\2\0\10\65\1\0\1\65\1\0"
			+ "\1\65\1\0\1\65\1\0\37\65\2\0\65\65\1\0\7\65\1\0"
			+ "\1\65\3\0\3\65\1\0\7\65\3\0\4\65\2\0\6\65\4\0"
			+ "\15\65\5\0\3\65\1\0\7\65\323\0\15\66\4\0\1\66\104\0"
			+ "\1\65\3\0\2\65\2\0\1\65\121\0\3\65\u0e82\0\1\66\1\0"
			+ "\1\65\31\0\11\65\6\66\1\0\5\66\13\0\124\65\4\0\2\66"
			+ "\2\0\2\66\2\0\132\65\1\0\3\66\6\0\50\65\u1cd3\0\u51a6\65"
			+ "\u0c5a\0\u2ba4\65\134\0\u0800\0\u1ffe\0\2\0";

	/**
	 * Translates characters to character classes
	 */
	private static final char[] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

	/**
	 * Translates DFA states to action switch labels.
	 */
	private static final int[] ZZ_ACTION = zzUnpackAction();

	private static final String ZZ_ACTION_PACKED_0 = "\1\1\4\0\1\2\2\0\3\2\3\0\1\3\1\0"
			+ "\1\4\12\2\1\5\1\2\1\6\4\0\1\1\1\7"
			+ "\2\10\2\11\3\10\1\12\2\13\2\10\1\2\4\14"
			+ "\1\15\3\16\1\10\1\17\1\20\1\21\1\10\1\21"
			+ "\3\10\1\22\1\10\1\23\1\24\1\3\1\10\2\3"
			+ "\1\4\1\25\1\10\2\26\1\7\1\27\1\30\1\31"
			+ "\1\7\1\10\1\32\1\33\1\7\1\34\4\10\1\35"
			+ "\2\10\1\36\1\10\3\36\1\37\1\10\3\37\1\40"
			+ "\1\10\2\40\2\5\1\41\1\42\1\10\2\42\2\6"
			+ "\1\43\2\44\3\45\1\46\1\47\1\50\1\10\1\46"
			+ "\1\51\1\10\1\52\2\53\1\54\1\0\1\1\1\0"
			+ "\1\1\3\0\1\55\3\14\1\56\1\57\2\0\1\21"
			+ "\6\0\1\3\2\0\1\60\1\61\1\0\1\62\1\0"
			+ "\1\31\6\0\1\63\5\0\2\36\2\0\2\36\2\0"
			+ "\1\63\3\0\1\37\3\0\1\63\3\0\2\40\2\0"
			+ "\2\40\1\0\2\53\1\5\3\0\2\42\2\0\2\42"
			+ "\1\0\2\53\1\6\1\64\1\0\1\65\4\0\2\1"
			+ "\1\66\2\0\1\67\1\70\1\71\2\72\1\14\6\0"
			+ "\1\36\2\0\1\40\1\0\2\5\1\0\1\42\1\0"
			+ "\2\6\1\0\1\73\1\0\1\1\1\74\1\0\2\14"
			+ "\7\0\2\5\1\0\2\6\2\0\2\14\5\0\2\5"
			+ "\2\6\1\53\1\0\1\14\1\75\3\0\1\76\1\77"
			+ "\1\53\1\5\1\53\1\6\1\0\1\14\1\100\1\101"
			+ "\1\102\1\5\1\6\1\0\1\14\1\5\1\6\1\103"
			+ "\1\14\2\103\4\14\1\104";

	private static int[] zzUnpackAction() {
		int[] result = new int[324];
		int offset = 0;
		offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
		return result;
	}

	private static int zzUnpackAction(String packed, int offset, int[] result) {
		int i = 0; /* index in packed string */
		int j = offset; /* index in unpacked array */
		int l = packed.length();
		while (i < l) {
			int count = packed.charAt(i++);
			int value = packed.charAt(i++);
			do
				result[j++] = value;
			while (--count > 0);
		}
		return j;
	}

	/**
	 * Translates a state to a row index in the transition table
	 */
	private static final int[] ZZ_ROWMAP = zzUnpackRowMap();

	private static final String ZZ_ROWMAP_PACKED_0 = "\0\0\0\73\0\166\0\261\0\354\0\u0127\0\u0162\0\u019d"
			+ "\0\u01d8\0\u0213\0\u024e\0\u0289\0\u02c4\0\u02ff\0\u033a\0\u0375"
			+ "\0\u03b0\0\u03eb\0\u0426\0\u0461\0\u049c\0\u04d7\0\u0512\0\u054d"
			+ "\0\u0588\0\u05c3\0\u05fe\0\u0639\0\u0674\0\u06af\0\u06ea\0\u0725"
			+ "\0\u0760\0\u079b\0\u07d6\0\u0811\0\u084c\0\u0887\0\u08c2\0\u08fd"
			+ "\0\u08c2\0\u08fd\0\u0938\0\u08c2\0\u08c2\0\u08fd\0\u0973\0\u09ae"
			+ "\0\u09e9\0\u0a24\0\u0a5f\0\u0a9a\0\u0ad5\0\u0b10\0\u08c2\0\u08fd"
			+ "\0\u0b4b\0\u0b86\0\u0bc1\0\u08c2\0\u0bfc\0\u0bfc\0\u0c37\0\u0c72"
			+ "\0\u0cad\0\u0b4b\0\u08c2\0\u0ce8\0\u0d23\0\u08c2\0\u0d5e\0\u0d99"
			+ "\0\u0dd4\0\u0e0f\0\u0e4a\0\u08c2\0\u0e85\0\u0ec0\0\u0efb\0\u0f36"
			+ "\0\u0f71\0\u08c2\0\u0fac\0\u0fe7\0\u1022\0\u105d\0\u1098\0\u10d3"
			+ "\0\u08c2\0\u110e\0\u1149\0\u1184\0\u11bf\0\u11fa\0\u1235\0\u1270"
			+ "\0\u12ab\0\u12ab\0\u12e6\0\u1321\0\u135c\0\u1397\0\u1397\0\u13d2"
			+ "\0\u140d\0\u1448\0\u1483\0\u1483\0\u14be\0\u14f9\0\u1534\0\u156f"
			+ "\0\u08c2\0\u15aa\0\u15aa\0\u15e5\0\u1620\0\u165b\0\u1696\0\u08c2"
			+ "\0\u08c2\0\u08fd\0\u08c2\0\u08fd\0\u16d1\0\u170c\0\u1747\0\u08c2"
			+ "\0\u1782\0\u17bd\0\u08c2\0\u17f8\0\u08c2\0\u1833\0\u08c2\0\u186e"
			+ "\0\u18a9\0\u18e4\0\u191f\0\u195a\0\u1995\0\u19d0\0\u1a0b\0\u08c2"
			+ "\0\u1a46\0\u1a81\0\u1abc\0\u08c2\0\u08c2\0\u0bfc\0\u0c72\0\u08c2"
			+ "\0\u0cad\0\u0ce8\0\u0d5e\0\u0d99\0\u1af7\0\u0dd4\0\u08c2\0\u1b32"
			+ "\0\u0e0f\0\u08c2\0\u1b6d\0\u0fac\0\u1ba8\0\u105d\0\u08c2\0\u1098"
			+ "\0\u186e\0\u1be3\0\u1c1e\0\u1c59\0\u11bf\0\u08c2\0\u1c94\0\u1ccf"
			+ "\0\u12ab\0\u1d0a\0\u12e6\0\u08c2\0\u1d45\0\u1d80\0\u1dbb\0\u1dbb"
			+ "\0\u1df6\0\u1e31\0\u135c\0\u12ab\0\u1397\0\u1e6c\0\u13d2\0\u08c2"
			+ "\0\u1ea7\0\u140d\0\u1448\0\u1397\0\u1483\0\u1ee2\0\u14be\0\u08c2"
			+ "\0\u1f1d\0\u1f58\0\u1f93\0\u1f93\0\u1fce\0\u2009\0\u2044\0\u1534"
			+ "\0\u207f\0\u15aa\0\u20ba\0\u15e5\0\u08c2\0\u20f5\0\u2130\0\u216b"
			+ "\0\u216b\0\u21a6\0\u21e1\0\u221c\0\u165b\0\u2257\0\u08c2\0\u1782"
			+ "\0\u08c2\0\u17f8\0\u2292\0\u22cd\0\u2308\0\u2343\0\u237e\0\u08c2"
			+ "\0\u23b9\0\u23f4\0\u08c2\0\u08c2\0\u08c2\0\u242f\0\u0a24\0\u246a"
			+ "\0\u24a5\0\u24e0\0\u251b\0\u2556\0\u2591\0\u1d45\0\u25cc\0\u25cc"
			+ "\0\u1f1d\0\u2607\0\u2607\0\u2642\0\u267d\0\u20f5\0\u26b8\0\u26b8"
			+ "\0\u26f3\0\u272e\0\u2769\0\u08c2\0\u27a4\0\u27df\0\u08c2\0\u281a"
			+ "\0\u2855\0\u2890\0\u28cb\0\u2906\0\u2941\0\u297c\0\u29b7\0\u1df6"
			+ "\0\u1fce\0\u29f2\0\u2a2d\0\u21a6\0\u2a68\0\u2aa3\0\u2ade\0\u2b19"
			+ "\0\u2b54\0\u2b8f\0\u2bca\0\u2c05\0\u2c40\0\u2c7b\0\u2cb6\0\u2cf1"
			+ "\0\u2d2c\0\u2d67\0\u2da2\0\u2ade\0\u2ddd\0\u2e18\0\u0a24\0\u2e53"
			+ "\0\u2e8e\0\u2ec9\0\u08c2\0\u08c2\0\u2cf1\0\u2f04\0\u2d67\0\u2f3f"
			+ "\0\u2f7a\0\u2fb5\0\u08c2\0\u08c2\0\u08c2\0\u2ff0\0\u302b\0\u3066"
			+ "\0\u30a1\0\u30dc\0\u3117\0\u08c2\0\u3152\0\u1534\0\u165b\0\u318d"
			+ "\0\u31c8\0\u3203\0\u323e\0\u0a24";

	private static int[] zzUnpackRowMap() {
		int[] result = new int[324];
		int offset = 0;
		offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
		return result;
	}

	private static int zzUnpackRowMap(String packed, int offset, int[] result) {
		int i = 0; /* index in packed string */
		int j = offset; /* index in unpacked array */
		int l = packed.length();
		while (i < l) {
			int high = packed.charAt(i++) << 16;
			result[j++] = high | packed.charAt(i++);
		}
		return j;
	}

	/**
	 * The transition table of the DFA
	 */
	private static final int[] ZZ_TRANS = zzUnpackTrans();

	private static final String ZZ_TRANS_PACKED_0 = "\1\43\1\44\11\43\1\45\4\43\1\46\52\43\1\47"
			+ "\1\50\71\47\1\51\1\52\17\51\1\53\1\51\1\54"
			+ "\47\51\1\55\1\56\71\55\1\51\1\52\6\51\1\57"
			+ "\12\51\1\54\50\51\1\52\2\51\1\60\1\51\1\61"
			+ "\2\51\1\62\3\51\1\61\5\51\1\61\1\51\4\62"
			+ "\1\63\6\62\1\64\11\62\1\65\2\62\2\51\3\62"
			+ "\1\51\3\62\1\51\2\62\3\51\1\52\2\51\1\60"
			+ "\1\51\1\66\6\51\1\66\5\51\1\66\47\51\1\67"
			+ "\1\70\2\67\1\71\16\67\1\54\47\67\1\51\1\52"
			+ "\2\51\1\72\1\51\1\61\2\51\1\73\3\51\1\61"
			+ "\5\51\1\61\1\51\30\73\2\51\3\73\1\51\3\73"
			+ "\1\51\2\73\3\51\1\52\2\51\1\72\1\74\1\61"
			+ "\2\51\1\73\3\51\1\61\5\51\1\61\1\51\30\73"
			+ "\2\51\3\73\1\51\3\73\1\51\2\73\2\51\1\75"
			+ "\1\52\1\51\1\76\1\77\1\75\1\61\3\75\1\100"
			+ "\1\75\1\101\1\61\5\75\1\61\47\75\1\51\1\52"
			+ "\2\51\1\102\16\51\1\54\50\51\1\52\1\103\1\104"
			+ "\5\51\1\105\11\51\1\54\1\51\30\105\2\51\3\105"
			+ "\1\51\3\105\1\51\2\105\3\51\1\52\1\103\1\104"
			+ "\1\51\1\106\3\51\1\105\11\51\1\54\1\51\30\105"
			+ "\2\51\3\105\1\51\3\105\1\51\2\105\2\51\1\107"
			+ "\1\52\1\103\1\110\2\107\1\51\3\107\1\111\1\107"
			+ "\1\112\1\51\5\107\1\54\47\107\1\51\1\52\21\51"
			+ "\1\54\47\51\1\113\1\44\1\114\1\115\5\113\1\116"
			+ "\13\113\30\117\2\113\3\117\1\113\3\117\1\113\2\117"
			+ "\2\113\1\51\1\120\1\114\1\115\2\51\1\61\2\51"
			+ "\1\121\3\51\1\61\5\51\1\61\1\51\30\121\2\51"
			+ "\3\121\1\51\3\121\1\51\2\121\3\51\1\120\1\114"
			+ "\1\115\1\51\1\122\1\61\2\51\1\121\3\51\1\61"
			+ "\5\51\1\61\1\51\30\121\2\51\3\121\1\51\3\121"
			+ "\1\51\2\121\2\51\1\123\1\124\1\114\1\125\2\123"
			+ "\1\61\3\123\1\126\1\123\1\127\1\61\5\123\1\61"
			+ "\47\123\1\51\1\130\1\131\3\51\1\61\6\51\1\61"
			+ "\5\51\1\61\2\51\1\132\1\133\5\51\1\134\7\51"
			+ "\1\134\1\51\1\133\1\132\23\51\1\52\1\131\3\51"
			+ "\1\61\6\51\1\61\5\51\1\61\1\135\47\51\1\52"
			+ "\1\131\3\51\1\61\2\51\1\136\3\51\1\61\5\51"
			+ "\1\61\1\135\30\136\2\51\3\136\1\51\3\136\1\51"
			+ "\2\136\3\51\1\52\1\131\3\51\1\61\6\51\1\61"
			+ "\5\51\1\61\1\135\12\51\1\137\4\51\1\140\12\51"
			+ "\1\137\13\51\1\141\1\52\1\131\1\142\2\141\1\61"
			+ "\3\141\1\143\1\141\1\144\1\61\5\141\1\61\1\145"
			+ "\46\141\1\146\1\52\1\131\1\147\2\146\1\61\3\146"
			+ "\1\150\1\146\1\151\1\61\5\146\1\61\1\152\46\146"
			+ "\1\153\1\52\1\131\1\154\2\153\1\61\3\153\1\155"
			+ "\1\153\1\156\1\61\5\153\1\61\47\153\1\157\1\160"
			+ "\1\161\70\157\1\162\1\52\1\131\1\163\2\162\1\61"
			+ "\3\162\1\164\1\162\1\165\1\61\5\162\1\61\47\162"
			+ "\1\166\1\167\1\170\70\166\1\171\1\172\71\171\1\173"
			+ "\1\174\2\173\1\175\13\173\1\175\52\173\1\176\1\177"
			+ "\12\176\1\200\41\176\1\201\12\176\1\201\1\176\1\202"
			+ "\1\177\10\202\1\203\43\202\1\204\12\202\1\204\1\202"
			+ "\1\43\1\0\11\43\1\0\4\43\1\0\52\43\3\0"
			+ "\1\205\1\206\13\0\1\207\1\0\1\210\56\0\1\211"
			+ "\2\0\1\212\3\0\1\211\5\0\1\211\1\0\30\212"
			+ "\1\0\1\213\3\212\1\0\3\212\1\0\2\212\10\0"
			+ "\1\211\2\0\1\214\3\0\1\211\5\0\1\211\1\0"
			+ "\30\214\2\0\3\214\1\0\3\214\1\0\2\214\101\0"
			+ "\1\206\13\0\1\207\1\0\1\215\71\0\1\216\61\0"
			+ "\1\217\64\0\1\220\76\0\1\61\6\0\1\61\5\0"
			+ "\1\61\56\0\3\62\4\0\1\62\6\0\30\62\2\0"
			+ "\3\62\1\0\6\62\11\0\3\62\4\0\1\62\6\0"
			+ "\5\62\1\221\21\62\1\222\2\0\3\62\1\0\6\62"
			+ "\11\0\3\62\4\0\1\62\6\0\5\62\1\223\21\62"
			+ "\1\223\2\0\3\62\1\0\6\62\11\0\3\62\4\0"
			+ "\1\62\6\0\5\62\1\222\21\62\1\222\2\0\3\62"
			+ "\1\0\6\62\10\0\1\66\6\0\1\66\5\0\1\66"
			+ "\51\0\1\224\72\0\1\225\77\0\3\73\4\0\1\73"
			+ "\6\0\30\73\2\0\3\73\1\0\6\73\2\0\1\75"
			+ "\2\0\1\226\2\75\1\0\3\75\1\0\1\75\2\0"
			+ "\5\75\1\0\50\75\1\0\1\225\1\226\2\75\1\0"
			+ "\3\75\1\0\1\75\2\0\5\75\1\0\47\75\1\227"
			+ "\1\0\10\227\1\230\60\227\1\231\1\0\12\231\1\230"
			+ "\56\231\2\0\1\103\1\232\76\0\3\105\4\0\1\105"
			+ "\6\0\30\105\2\0\3\105\1\0\6\105\2\0\1\107"
			+ "\2\0\1\233\2\107\1\0\3\107\1\0\1\107\2\0"
			+ "\5\107\1\0\50\107\1\0\1\103\1\234\2\107\1\0"
			+ "\3\107\1\0\1\107\2\0\5\107\1\0\47\107\1\111"
			+ "\1\0\1\235\1\236\2\111\1\235\3\111\1\237\1\111"
			+ "\2\235\5\111\1\235\47\111\1\112\1\0\1\240\1\241"
			+ "\2\112\1\240\3\112\1\240\1\112\1\237\1\240\5\112"
			+ "\1\240\47\112\1\113\3\0\21\113\30\0\2\113\3\0"
			+ "\1\113\3\0\1\113\2\0\2\113\2\0\1\242\70\0"
			+ "\1\113\3\0\3\113\3\116\4\113\1\116\6\113\30\117"
			+ "\2\113\3\117\1\113\3\117\1\116\2\117\2\113\7\0"
			+ "\3\117\4\0\1\117\6\0\30\117\2\0\3\117\1\0"
			+ "\6\117\5\0\1\205\1\206\4\0\1\243\6\0\1\207"
			+ "\1\0\1\210\2\0\30\243\2\0\3\243\1\0\3\243"
			+ "\1\0\2\243\11\0\3\121\4\0\1\121\6\0\30\121"
			+ "\2\0\3\121\1\0\6\121\2\0\1\123\2\0\1\244"
			+ "\2\123\1\0\3\123\1\0\1\123\2\0\5\123\1\0"
			+ "\47\123\3\0\1\205\1\206\4\0\1\245\6\0\1\207"
			+ "\1\0\1\210\2\0\30\245\2\0\3\245\1\0\3\245"
			+ "\1\0\2\245\2\0\1\123\1\0\1\242\1\244\2\123"
			+ "\1\0\3\123\1\0\1\123\2\0\5\123\1\0\47\123"
			+ "\1\246\1\0\10\246\1\247\60\246\1\250\1\0\12\250"
			+ "\1\247\56\250\3\0\1\205\1\206\13\0\1\207\1\0"
			+ "\1\251\111\0\1\252\61\0\1\253\15\0\1\253\57\0"
			+ "\1\254\17\0\1\254\17\0\21\255\1\256\51\255\7\0"
			+ "\3\136\4\0\1\136\6\0\30\136\2\0\3\136\1\0"
			+ "\6\136\45\0\1\257\5\0\1\257\102\0\1\260\11\0"
			+ "\1\141\2\0\1\261\2\141\1\0\3\141\1\0\1\141"
			+ "\2\0\5\141\1\0\47\141\1\143\1\0\1\262\1\263"
			+ "\2\143\1\262\3\143\1\264\1\143\2\262\5\143\1\262"
			+ "\47\143\1\265\1\0\1\266\1\267\2\270\1\266\3\270"
			+ "\1\266\1\265\1\271\1\272\3\270\1\265\1\270\1\272"
			+ "\1\265\30\270\1\265\7\270\2\265\3\270\1\265\1\145"
			+ "\2\255\1\273\2\145\1\255\3\145\1\255\1\145\2\255"
			+ "\3\145\1\274\1\145\1\255\47\145\1\146\2\0\1\275"
			+ "\2\146\1\0\3\146\1\0\1\146\2\0\5\146\1\0"
			+ "\47\146\1\150\2\276\1\277\2\150\1\276\3\150\1\300"
			+ "\1\150\2\276\5\150\1\276\47\150\1\151\2\301\1\302"
			+ "\2\151\1\301\3\151\1\301\1\151\1\300\1\301\5\151"
			+ "\1\301\47\151\1\152\2\255\1\303\2\152\1\255\3\152"
			+ "\1\255\1\152\2\255\3\152\1\304\1\152\1\255\47\152"
			+ "\1\153\2\0\1\305\2\153\1\0\3\153\1\0\1\153"
			+ "\2\0\5\153\1\0\47\153\1\155\1\0\1\306\1\307"
			+ "\2\155\1\306\3\155\1\310\1\155\2\306\5\155\1\306"
			+ "\47\155\1\311\1\0\1\312\1\313\2\314\1\312\3\314"
			+ "\1\312\1\311\1\315\1\316\3\314\1\311\1\314\1\316"
			+ "\1\311\30\314\1\311\7\314\2\311\3\314\1\311\2\157"
			+ "\1\0\72\157\1\0\1\157\1\317\13\157\1\320\1\157"
			+ "\1\321\50\157\1\162\2\0\1\322\2\162\1\0\3\162"
			+ "\1\0\1\162\2\0\5\162\1\0\47\162\1\164\1\0"
			+ "\1\323\1\324\2\164\1\323\3\164\1\325\1\164\2\323"
			+ "\5\164\1\323\47\164\1\326\1\0\1\327\1\330\2\331"
			+ "\1\327\3\331\1\327\1\326\1\332\1\333\3\331\1\326"
			+ "\1\331\1\333\1\326\30\331\1\326\7\331\2\326\3\331"
			+ "\1\326\2\166\1\0\72\166\1\0\1\166\1\334\13\166"
			+ "\1\335\1\166\1\336\50\166\2\0\1\337\70\0\1\176"
			+ "\1\0\12\176\1\0\41\176\1\340\12\176\1\340\1\176"
			+ "\3\0\1\341\1\206\13\0\1\207\1\0\1\215\50\0"
			+ "\72\176\1\0\1\202\1\0\10\202\1\0\43\202\1\342"
			+ "\12\202\1\342\73\202\6\0\1\207\36\0\1\343\36\0"
			+ "\1\344\13\0\1\345\54\0\1\211\2\0\1\43\3\0"
			+ "\1\211\5\0\1\211\1\0\30\43\2\0\3\43\1\0"
			+ "\3\43\1\0\2\43\2\0\1\346\1\0\4\346\1\347"
			+ "\3\212\1\346\1\0\1\346\1\347\1\212\1\346\1\0"
			+ "\2\346\1\347\1\346\30\212\2\346\3\212\1\350\6\212"
			+ "\2\346\16\0\1\351\12\0\1\352\41\0\1\346\1\0"
			+ "\4\346\1\347\3\214\1\346\1\0\1\346\1\347\1\214"
			+ "\1\346\1\0\2\346\1\347\1\346\30\214\2\346\3\214"
			+ "\1\353\6\214\2\346\24\0\1\345\50\0\1\354\72\0"
			+ "\1\355\77\0\3\62\4\0\1\62\6\0\6\62\1\356"
			+ "\17\62\1\357\1\62\2\0\3\62\1\0\6\62\11\0"
			+ "\3\62\4\0\1\62\6\0\6\62\1\357\17\62\1\357"
			+ "\1\62\2\0\3\62\1\0\6\62\11\0\3\62\4\0"
			+ "\1\62\6\0\17\62\1\360\10\62\2\0\3\62\1\0"
			+ "\6\62\2\0\1\235\1\0\10\235\1\237\60\235\1\240"
			+ "\1\0\12\240\1\237\56\240\7\0\3\243\4\0\1\243"
			+ "\6\0\30\243\2\0\3\243\1\0\6\243\11\0\3\245"
			+ "\4\0\1\245\6\0\30\245\2\0\3\245\1\0\6\245"
			+ "\27\0\1\361\36\0\1\361\36\0\1\362\15\0\1\362"
			+ "\61\0\1\363\7\0\1\363\64\0\1\364\17\0\1\364"
			+ "\76\0\1\365\7\0\1\262\1\0\10\262\1\264\60\262"
			+ "\1\265\1\0\1\266\1\366\2\265\1\266\3\265\1\266"
			+ "\1\265\1\264\1\266\5\265\1\266\47\265\1\266\1\0"
			+ "\12\266\1\264\56\266\1\265\1\0\1\266\1\366\2\265"
			+ "\1\266\3\265\1\266\1\265\1\367\1\266\5\265\1\266"
			+ "\47\265\14\0\1\370\56\0\1\266\1\0\12\266\1\367"
			+ "\56\266\12\276\1\300\60\276\14\301\1\300\56\301\1\306"
			+ "\1\0\10\306\1\310\60\306\1\311\1\0\1\312\1\371"
			+ "\2\311\1\312\3\311\1\312\1\311\1\310\1\312\5\311"
			+ "\1\312\47\311\1\312\1\0\12\312\1\310\56\312\1\311"
			+ "\1\0\1\312\1\371\2\311\1\312\3\311\1\312\1\311"
			+ "\1\372\1\312\5\311\1\312\47\311\14\0\1\373\56\0"
			+ "\1\312\1\0\12\312\1\372\56\312\2\157\1\0\2\157"
			+ "\1\320\36\157\1\374\30\157\1\0\21\157\1\375\46\157"
			+ "\1\323\1\0\10\323\1\325\60\323\1\326\1\0\1\327"
			+ "\1\376\2\326\1\327\3\326\1\327\1\326\1\325\1\327"
			+ "\5\326\1\327\47\326\1\327\1\0\12\327\1\325\56\327"
			+ "\1\326\1\0\1\327\1\376\2\326\1\327\3\326\1\327"
			+ "\1\326\1\377\1\327\5\326\1\327\47\326\14\0\1\u0100"
			+ "\56\0\1\327\1\0\12\327\1\377\56\327\2\166\1\0"
			+ "\2\166\1\335\36\166\1\u0101\30\166\1\0\21\166\1\u0102"
			+ "\46\166\67\0\2\u0103\12\0\1\u0104\107\0\1\u0105\45\0"
			+ "\1\346\1\0\11\346\1\0\4\346\1\0\41\346\1\0"
			+ "\11\346\1\0\4\346\1\347\4\346\1\0\1\346\1\347"
			+ "\2\346\1\0\2\346\1\347\36\346\1\u0106\10\346\16\0"
			+ "\1\351\43\0\1\u0107\26\0\1\u0108\6\0\3\u0108\5\0"
			+ "\1\u0108\7\0\1\u0108\1\0\2\u0108\7\0\1\u0108\2\0"
			+ "\2\u0108\15\0\1\62\1\u0109\1\62\4\0\1\62\6\0"
			+ "\30\62\2\0\3\62\1\0\6\62\11\0\3\62\4\0"
			+ "\1\62\6\0\14\62\1\u010a\13\62\2\0\3\62\1\0"
			+ "\6\62\32\0\1\u010b\15\0\1\u010b\57\0\1\u010c\17\0"
			+ "\1\u010c\51\0\1\u010d\21\0\1\u010d\46\0\1\u010e\15\0"
			+ "\1\u010e\57\0\1\u010f\17\0\1\u010f\22\0\3\u0110\1\0"
			+ "\3\u0110\2\0\1\271\4\u0110\1\0\2\u0110\1\0\30\u0110"
			+ "\1\0\7\u0110\2\0\3\u0110\4\0\3\u0111\1\0\3\u0111"
			+ "\2\0\1\315\4\u0111\1\0\2\u0111\1\0\30\u0111\1\0"
			+ "\7\u0111\2\0\3\u0111\1\0\2\157\1\0\64\157\2\u0112"
			+ "\4\157\1\0\22\157\1\u0113\45\157\3\0\3\u0114\1\0"
			+ "\3\u0114\2\0\1\332\4\u0114\1\0\2\u0114\1\0\30\u0114"
			+ "\1\0\7\u0114\2\0\3\u0114\1\0\2\166\1\0\64\166"
			+ "\2\u0115\4\166\1\0\22\166\1\u0116\45\166\44\0\1\u0117"
			+ "\10\0\1\u0117\43\0\1\u0118\126\0\1\u0106\26\0\1\u0108"
			+ "\6\0\3\u0108\5\0\1\u0108\7\0\1\u0108\1\0\2\u0108"
			+ "\7\0\1\u0108\1\0\1\u0107\2\u0108\15\0\3\62\4\0"
			+ "\1\62\6\0\12\62\1\u0119\15\62\2\0\3\62\1\0"
			+ "\6\62\11\0\3\62\4\0\1\62\6\0\11\62\1\u011a"
			+ "\16\62\2\0\3\62\1\0\6\62\45\0\1\u011b\5\0"
			+ "\1\u011b\61\0\1\u011c\67\0\1\u011d\7\0\1\u011d\62\0"
			+ "\1\u011e\7\0\1\u011e\65\0\1\u011f\32\0\2\157\1\0"
			+ "\41\157\1\u0120\10\157\1\u0120\17\157\1\0\23\157\1\u0121"
			+ "\44\157\2\166\1\0\41\166\1\u0122\10\166\1\u0122\17\166"
			+ "\1\0\23\166\1\u0123\44\166\6\0\1\u0124\6\0\1\u0124"
			+ "\5\0\1\u0124\76\0\1\u0125\52\0\3\62\4\0\1\62"
			+ "\6\0\21\62\1\u0126\6\62\2\0\3\62\1\0\6\62"
			+ "\11\0\3\62\4\0\1\62\6\0\3\62\1\u0127\15\62"
			+ "\1\u0127\6\62\2\0\3\62\1\0\6\62\46\0\1\u0128"
			+ "\65\0\1\u0129\17\0\1\u0129\55\0\1\u012a\62\0\1\u012b"
			+ "\21\0\1\u012b\43\0\1\u012c\36\0\1\u012c\6\0\2\157"
			+ "\1\0\3\157\1\u012d\6\157\1\u012d\5\157\1\u012d\51\157"
			+ "\1\0\24\157\1\u012e\43\157\2\166\1\0\3\166\1\u012f"
			+ "\6\166\1\u012f\5\166\1\u012f\51\166\1\0\24\166\1\u0130"
			+ "\43\166\30\0\1\u0131\51\0\3\62\4\0\1\62\6\0"
			+ "\24\62\1\u0132\3\62\2\0\3\62\1\0\6\62\37\0"
			+ "\1\u0133\7\0\1\u0133\55\0\1\u0134\15\0\1\u0134\54\0"
			+ "\1\u0135\15\0\1\u0135\24\0\2\157\1\0\25\157\1\u0136"
			+ "\42\157\2\166\1\0\25\166\1\u0137\42\166\27\0\1\u0138"
			+ "\52\0\3\62\4\0\1\62\6\0\6\62\1\u0139\21\62"
			+ "\2\0\3\62\1\0\6\62\2\0\2\157\1\0\24\157"
			+ "\1\u013a\43\157\2\166\1\0\24\166\1\u013b\43\166\24\0"
			+ "\1\u013c\55\0\3\62\4\0\1\62\6\0\10\62\1\u013d"
			+ "\17\62\2\0\3\62\1\0\6\62\2\0\2\157\1\0"
			+ "\21\157\1\u013e\46\157\2\166\1\0\21\166\1\u013f\46\166"
			+ "\7\0\3\62\4\0\1\62\6\0\12\62\1\u0140\15\62"
			+ "\2\0\3\62\1\0\6\62\11\0\3\62\4\0\1\62"
			+ "\6\0\30\62\2\0\3\62\1\0\4\62\1\u0141\1\62"
			+ "\11\0\3\62\4\0\1\62\6\0\10\62\1\u0142\17\62"
			+ "\2\0\3\62\1\0\6\62\11\0\3\62\4\0\1\62"
			+ "\6\0\10\62\1\u0143\17\62\2\0\3\62\1\0\6\62"
			+ "\11\0\3\62\4\0\1\62\6\0\21\62\1\u0144\6\62"
			+ "\2\0\3\62\1\0\6\62\2\0";

	private static int[] zzUnpackTrans() {
		int[] result = new int[12921];
		int offset = 0;
		offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
		return result;
	}

	private static int zzUnpackTrans(String packed, int offset, int[] result) {
		int i = 0; /* index in packed string */
		int j = offset; /* index in unpacked array */
		int l = packed.length();
		while (i < l) {
			int count = packed.charAt(i++);
			int value = packed.charAt(i++);
			value--;
			do
				result[j++] = value;
			while (--count > 0);
		}
		return j;
	}

	/* error codes */
	final private static int ZZ_UNKNOWN_ERROR = 0;
	final private static int ZZ_NO_MATCH = 1;
	final private static int ZZ_PUSHBACK_2BIG = 2;

	/* error messages for the codes above */
	final private static String ZZ_ERROR_MSG[] = {
			"Unkown internal scanner error", //$NON-NLS-1$
			"Error: could not match input", //$NON-NLS-1$
			"Error: pushback value was too large" //$NON-NLS-1$
	};

	/**
	 * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
	 */
	private static final int[] ZZ_ATTRIBUTE = zzUnpackAttribute();

	private static final String ZZ_ATTRIBUTE_PACKED_0 = "\1\1\4\0\1\1\2\0\3\1\3\0\1\1\1\0"
			+ "\16\1\4\0\4\1\1\11\1\1\1\11\2\1\2\11"
			+ "\11\1\1\11\4\1\1\11\6\1\1\11\2\1\1\11"
			+ "\5\1\1\11\5\1\1\11\6\1\1\11\27\1\1\11"
			+ "\6\1\2\11\1\1\1\11\4\1\1\11\2\1\1\11"
			+ "\1\1\1\11\1\1\1\11\1\1\1\0\1\1\1\0"
			+ "\1\1\3\0\1\11\3\1\2\11\2\0\1\11\6\0"
			+ "\1\11\2\0\1\11\1\1\1\0\1\1\1\0\1\11"
			+ "\6\0\1\11\5\0\1\11\1\1\2\0\2\1\2\0"
			+ "\1\1\3\0\1\11\3\0\1\1\3\0\1\11\1\1"
			+ "\2\0\2\1\1\0\3\1\3\0\1\11\1\1\2\0"
			+ "\2\1\1\0\3\1\1\11\1\0\1\11\4\0\2\1"
			+ "\1\11\2\0\3\11\3\1\6\0\1\1\2\0\1\1"
			+ "\1\0\2\1\1\0\1\1\1\0\2\1\1\0\1\11"
			+ "\1\0\1\1\1\11\1\0\2\1\7\0\2\1\1\0"
			+ "\2\1\2\0\2\1\5\0\5\1\1\0\2\1\3\0"
			+ "\2\11\4\1\1\0\1\1\3\11\2\1\1\0\3\1" + "\1\11\10\1";

	private static int[] zzUnpackAttribute() {
		int[] result = new int[324];
		int offset = 0;
		offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
		return result;
	}

	private static int zzUnpackAttribute(String packed, int offset, int[] result) {
		int i = 0; /* index in packed string */
		int j = offset; /* index in unpacked array */
		int l = packed.length();
		while (i < l) {
			int count = packed.charAt(i++);
			int value = packed.charAt(i++);
			do
				result[j++] = value;
			while (--count > 0);
		}
		return j;
	}

	/** the input device */
	private java.io.Reader zzReader;

	/** the current state of the DFA */
	private int zzState;

	/** the current lexical state */
	private int zzLexicalState = YYINITIAL;

	/**
	 * this buffer contains the current text to be matched and is the source of
	 * the yytext() string
	 */
	private char zzBuffer[] = new char[ZZ_BUFFERSIZE];

	/** the textposition at the last accepting state */
	private int zzMarkedPos;

	/** the textposition at the last state to be included in yytext */
	private int zzPushbackPos;

	/** the current text position in the buffer */
	private int zzCurrentPos;

	/** startRead marks the beginning of the yytext() string in the buffer */
	private int zzStartRead;

	/**
	 * endRead marks the last character in the buffer, that has been read from
	 * input
	 */
	private int zzEndRead;

	/** number of newlines encountered up to the start of the matched text */
	private int yyline;

	/** the number of characters up to the start of the matched text */
	private int yychar;

	/**
	 * the number of characters from the last newline up to the start of the
	 * matched text
	 */
	// private int yycolumn;

	/**
	 * zzAtBOL == true <=> the scanner is currently at the beginning of a line
	 */
	// private boolean zzAtBOL = true;

	/** zzAtEOF == true <=> the scanner is at the EOF */
	private boolean zzAtEOF;

	/** denotes if the user-EOF-code has already been executed */
	private boolean zzEOFDone;

	/* user code: */
	// where the last internal container block was found
	private int fLastInternalBlockStart = -1;

	private int fTokenCount = 0;

	// required holders for white-space compacting
	private boolean fShouldLoadBuffered = false;
	private String fBufferedContext = null;
	private String fBufferedText = null;
	private int fBufferedStart = 1;
	private int fBufferedLength = 0;

	// help for php container text region
	private ContextRegionContainer fBufferedEmbeddedContainer = null;
	private String f_context = null;

	// state stack for handling embedded regions
	private IntStack fStateStack = new IntStack();

	// a "hint" as to what an embedded region should be evaluated
	private String fEmbeddedHint = UNDEFINED;
	// a "hint" as to what state to enter once an embedded region has
	// been completed
	private int fEmbeddedPostState = YYINITIAL;
	// the container used to create embedded regions
	private ContextRegionContainer fEmbeddedContainer = null;
	private static final String PROXY_CONTEXT = "PROXY_CONTEXT";

	private String context = null;
	private String text = null;
	private int start = 0;
	private int textLength = 0;
	private int length = 0;

	// offset for tracking position specific block tags
	private int fOffset = 0;

	// the name of the current tag being opened
	private String fCurrentTagName = null;

	// the list of tag name BlockMarkers
	private List fBlockMarkers = new ArrayList();

	// required to not seek text blocks on an end tag
	private boolean fIsBlockingEnabled = false;
	private boolean fIsCaseSensitiveBlocking = true;

	// the name of the current tag inside of an embedded region
	private String internalTagName = null;
	private String internalContext = null;

	private final XMLParserRegionFactory fRegionFactory = new XMLParserRegionFactory();
	private PHPVersion phpVersion = ProjectOptions.getDefaultPhpVersion();

	/**
	 * user method
	 */
	public final void addBlockMarker(BlockMarker marker) {
		if (containsTagName(marker.getTagName()))
			return;
		fBlockMarkers.add(marker);
	}

	/**
	 * user method
	 */
	public final void removeBlockMarker(BlockMarker marker) {
		fBlockMarkers.remove(marker);
	}

	/**
	 * user method
	 */
	public final void removeBlockMarker(String tagname) {
		if (fBlockMarkers != null) {
			Iterator blocks = fBlockMarkers.iterator();
			while (blocks.hasNext()) {
				if (((BlockMarker) blocks.next()).getTagName().equals(tagname))
					blocks.remove();
			}
		}
	}

	/* user method */
	public boolean getBlockMarkerCaseSensitivity() {
		return getBlockMarkerCaseSensitivity(fCurrentTagName);
	}

	/* user method */
	public boolean getBlockMarkerCaseSensitivity(String name) {
		Iterator iterator = fBlockMarkers.iterator();
		while (iterator.hasNext()) {
			BlockMarker marker = (BlockMarker) iterator.next();
			boolean casesensitive = marker.isCaseSensitive();
			if (casesensitive && marker.getTagName().equals(name))
				return casesensitive;
			else if (!casesensitive
					&& marker.getTagName().equalsIgnoreCase(name))
				return casesensitive;
		}
		return true;
	}

	/* user method */
	public String getBlockMarkerContext() {
		return getBlockMarkerContext(fCurrentTagName);
	}

	/* user method */
	public String getBlockMarkerContext(String name) {
		Iterator iterator = fBlockMarkers.iterator();
		while (iterator.hasNext()) {
			BlockMarker marker = (BlockMarker) iterator.next();
			if (marker.getTagName().equals(name))
				return marker.getContext();
		}
		return BLOCK_TEXT;
	}

	/* user method */
	public List getBlockMarkers() {
		return fBlockMarkers;
	}

	/* user method */
	public final int getOffset() {
		return fOffset + yychar;
	}

	private final boolean isBlockMarker() {
		return isBlockMarker(fCurrentTagName);
	}

	private final boolean isBlockMarker(String tagName) {
		if (!fIsBlockingEnabled)
			return false;
		return containsTagName(tagName);
	}

	/**
	 * user method
	 */
	public final void beginBlockTagScan(String newTagName) {
		beginBlockMarkerScan(newTagName, BLOCK_TEXT);
	}

	/**
	 * user method
	 * 
	 * Special tokenizer setup. Allows tokenization to be initiated at the start
	 * of a text block within a "newTagName" tag.
	 * 
	 * Example: Tokenizer toker = new Tokenizer();
	 * toker.setCaseSensitiveBlocking(false); toker.reset(new
	 * java.io.StringReader
	 * ("afiuhqwkejhtasihgalkwhtq</scripter></scr></script>asgdasga"));
	 * toker.beginBlockMarkerScan("script", BLOCK_TEXT); toker.getRegions();
	 * 
	 * Returns: BLOCK_TEXT: 0-40 XML_END_TAG_OPEN: 41-42 XML_TAG_NAME: 43-48
	 * XML_TAG_CLOSE: 49-49 XML_CONTENT: 50-57
	 * 
	 */
	public final void beginBlockMarkerScan(String newTagName,
			String blockcontext) {
		yybegin(ST_BLOCK_TAG_SCAN);
		fCurrentTagName = newTagName;
	}

	/**
	 * Method doScan.
	 * 
	 * Returns a context region for all of the text from the current position
	 * upto the end of input or to right *before* the first occurence of
	 * searchString
	 * 
	 * @param searchString
	 *            - target string to search for ex.: "-->", "</tagname"
	 * @param requireTailSeparator
	 *            - whether the target must be immediately followed by
	 *            whitespace or '>'
	 * @param context
	 *            - the context of the scanned region if non-zero length
	 * @param exitState
	 *            - the state to go to if the region was of non-zero length
	 * @param abortState
	 *            - the state to go to if the searchString was found immediately
	 * @return String - the context found: the desired context on a non-zero
	 *         length match, the abortContext on immediate success
	 * @throws IOException
	 */
	private final String doScan(String searchString, boolean allowPHP,
			boolean requireTailSeparator, String searchContext, int exitState,
			int immediateFallbackState) throws IOException {
		boolean stillSearching = true;
		// Disable further block (probably)
		fIsBlockingEnabled = false;
		int searchStringLength = searchString.length();
		int n = 0;
		char lastCheckChar;
		int i;
		boolean same = false;
		while (stillSearching) {
			n = 0;
			// Ensure that enough data from the input exists to compare against
			// the search String.
			n = yy_advance();
			while (n != YYEOF && zzCurrentPos < searchStringLength)
				n = yy_advance();
			// If the input was too short or we've exhausted the input, stop
			// immediately.
			if (n == YYEOF) {
				stillSearching = false;
			} else {

				/**
				 * Look for starting PHPs "<?"
				 */
				// Look for a PHP beginning at the current position; this case
				// wouldn't be handled by the preceding section
				// since it relies upon *having* closeTagStringLength amount of
				// input to work as designed. Must be sure we don't
				// spill over the end of the buffer while checking.
				if (allowPHP
						&& zzStartRead != fLastInternalBlockStart
						&& zzCurrentPos > 0
						&& zzCurrentPos < zzBuffer.length - 1
						&& zzBuffer[zzCurrentPos - 1] == '<'
						&& (zzBuffer[zzCurrentPos] == '?' || (zzBuffer[zzCurrentPos] == '%' && ProjectOptions
								.isSupportingAspTags(project)))) {
					fLastInternalBlockStart = zzMarkedPos = zzCurrentPos - 1;
					zzCurrentPos = zzMarkedPos + 1;
					int resumeState = yystate();
					yybegin(ST_BLOCK_TAG_INTERNAL_SCAN);
					if (zzMarkedPos == zzStartRead) {
						String jspContext = primGetNextToken();
						yybegin(resumeState);
						return jspContext;
					}
					return searchContext;
				}

				// 2) zzCurrentPos - jspstarter.length : There's not
				// searchStringLength of input available; check for a JSP 2
				// spots back in what we could read
				// ---
				// Look for a JSP beginning at the current position; this case
				// wouldn't be handled by the preceding section
				// since it relies upon *having* closeTagStringLength amount of
				// input to work as designed. Must be sure we don't
				// spill over the end of the buffer while checking.
				else if (allowPHP && zzStartRead != fLastInternalBlockStart
						&& zzCurrentPos > 0
						&& zzCurrentPos < zzBuffer.length - 1
						&& zzBuffer[zzCurrentPos - 1] == '<'
						&& zzBuffer[zzCurrentPos] == '?') {
					fLastInternalBlockStart = zzMarkedPos = zzCurrentPos - 1;
					zzCurrentPos = zzMarkedPos + 1;
					int resumeState = yystate();
					yybegin(ST_BLOCK_TAG_INTERNAL_SCAN);
					if (zzMarkedPos == zzStartRead) {
						String jspContext = primGetNextToken();
						yybegin(resumeState);
						return jspContext;
					}
					return searchContext;
				}
				// 3) zzCurrentPos..(zzCurrentPos+jspStartlength-1) : Check at
				// the start of the block one time
				// ---
				// Look for a JSP beginning immediately in the block area; this
				// case wouldn't be handled by the preceding section
				// since it relies upon zzCurrentPos equaling exactly the
				// previous end +1 to work as designed.
				else if (allowPHP && zzStartRead != fLastInternalBlockStart
						&& zzStartRead > 0 && zzStartRead < zzBuffer.length - 1
						&& zzBuffer[zzStartRead] == '<'
						&& zzBuffer[zzStartRead + 1] == '?') {
					fLastInternalBlockStart = zzMarkedPos = zzStartRead;
					zzCurrentPos = zzMarkedPos + 1;
					int resumeState = yystate();
					yybegin(ST_BLOCK_TAG_INTERNAL_SCAN);
					if (zzMarkedPos == zzStartRead) {
						String jspContext = primGetNextToken();
						yybegin(resumeState);
						return jspContext;
					}
					return searchContext;
				}

				// Check the characters in the target versus the last
				// targetLength characters read from the buffer
				// and see if it matches
				if (n == YYEOF) {
					stillSearching = false;
				} else {
					same = true;
					// Ensure that we've not encountered a complete block (<%%>)
					// that was *shorter* than the closeTagString and
					// thus found twice at current-targetLength [since the first
					// scan would have come out this far anyway].
					// Check the characters in the target versus the last
					// targetLength characters read from the buffer
					// and see if it matches

					// safety check for array accesses (zzCurrentPos is the
					// *last* character we can check against)
					if (zzCurrentPos >= searchStringLength
							&& zzCurrentPos <= zzBuffer.length) {
						for (i = 0; i < searchStringLength; i++) {
							if (same && fIsCaseSensitiveBlocking)
								same = zzBuffer[i + zzCurrentPos
										- searchStringLength] == searchString
										.charAt(i);
							else if (same && !fIsCaseSensitiveBlocking)
								same = Character.toLowerCase(zzBuffer[i
										+ zzCurrentPos - searchStringLength]) == Character
										.toLowerCase(searchString.charAt(i));
						}
					}
					// safety check failed; no match is possible right now
					else {
						same = false;
					}
				}
				if (same && requireTailSeparator
						&& zzCurrentPos < zzBuffer.length) {
					// Additional check for close tags to ensure that
					// targetString="</script" doesn't match
					// "</scriptS"
					lastCheckChar = zzBuffer[zzCurrentPos];
					// Succeed on "</script>" and "</script "
					if (lastCheckChar == '>'
							|| Character.isWhitespace(lastCheckChar))
						stillSearching = false;
				} else {
					stillSearching = !same
							|| (zzCurrentPos < zzStartRead + searchStringLength);
				}
			}
		}
		if (n != YYEOF || same) {
			// We've stopped short of the end or definitely found a match
			zzMarkedPos = zzCurrentPos - searchStringLength;
			zzCurrentPos = zzMarkedPos + 1;
			// If the searchString occurs at the very beginning of what would
			// have
			// been a Block, resume scanning normally immediately
			if (zzMarkedPos == zzStartRead) {
				yybegin(immediateFallbackState);
				return primGetNextToken();
			}
		} else {
			// We ran through the rest of the input
			zzMarkedPos = zzCurrentPos;
			zzCurrentPos++;
		}
		yybegin(exitState);
		// If the ending occurs at the very beginning of what would have
		// been a Block, resume scanning normally immediately
		if (zzMarkedPos == zzStartRead)
			return primGetNextToken();
		return searchContext;
	}

	/**
	 * Method doScanEndPhp
	 * 
	 * @see doScan(searchString, req...) this version can handle two strings as
	 *      options to search string it originally written to support ?> or %>
	 *      close tags to php The two strings must be on the same length
	 * 
	 * @param isAsp
	 *            - whether the asp %> close is premited
	 * @param context
	 *            - the context of the scanned region if non-zero length
	 * @param exitState
	 *            - the state to go to if the region was of non-zero length
	 * @param abortState
	 *            - the state to go to if the searchString was found immediately
	 * @return String - the context found: the desired context on a non-zero
	 *         length match, the abortContext on immediate success
	 * @throws IOException
	 */
	private ITextRegion bufferedTextRegion = null;

	private final String doScanEndPhp(boolean isAsp, String searchContext,
			int exitState, int immediateFallbackState) throws IOException {
		yypushback(1); // begin with the last char

		final AbstractPhpLexer phpLexer = getPhpLexer();
		bufferedTextRegion = new PhpScriptRegion(searchContext, yychar,
				project, phpLexer);

		// restore the locations / states
		reset(zzReader, phpLexer.getZZBuffer(), phpLexer.getParamenters());

		yybegin(exitState);
		return searchContext;
	}

	/**
	 * @param project
	 * @param stream
	 * @return a new lexer for the given project with the given stream
	 *         initialized with current parameters
	 */
	private AbstractPhpLexer getPhpLexer() {
		final AbstractPhpLexer lexer = PhpLexerFactory.createLexer(zzReader,
				phpVersion);
		int[] currentParameters = getParamenters();
		try {
			// set initial lexer state - we use reflection here since we don't
			// know the constant value of
			// of this state in specific PHP version lexer
			currentParameters[6] = lexer.getClass()
					.getField("ST_PHP_IN_SCRIPTING").getInt(lexer);
		} catch (Exception e) {
			Logger.logException(e);
		}
		lexer.initialize(currentParameters[6]);
		lexer.reset(zzReader, zzBuffer, currentParameters);
		lexer.setPatterns(project);

		lexer.setAspTags(ProjectOptions.isSupportingAspTags(project));
		return lexer;
	}

	// call the doScan without searching for PHP internal code
	private final String doScan(String searchString,
			boolean requireTailSeparator, String searchContext, int exitState,
			int immediateFallbackState) throws IOException {
		return doScan(searchString, true, requireTailSeparator, searchContext,
				exitState, immediateFallbackState);
	}

	/* user method */
	private final void assembleEmbeddedTagSequence(String startType,
			String endTagName) {
		assembleEmbeddedContainer(startType, null, endTagName);
	}

	/* user method */
	private final void assembleEmbeddedContainer(String startType,
			String[] endTypes) {
		assembleEmbeddedContainer(startType, endTypes, null);
	}

	/* user method */
	private final void assembleEmbeddedContainer(String startType,
			String endType) {
		assembleEmbeddedContainer(startType, new String[] { endType }, null);
	}

	/**
	 * user method
	 * 
	 * Assembles an embedded container beginning with the given startType as the
	 * first ContextRegion within it and of the type fEmbeddedHint. The
	 * endTypes[] array contains the context types that will cause a successful
	 * exit. Use of the endTagName parameter alters this behavior to force an
	 * exit on an XML_TAG_CLOSE after seeing an XML_TAG_NAME whose significant
	 * text matches the endTagName String. All contents in between are
	 * insignificant, and yes, this means comments are allowed inside.
	 **/
	private final void assembleEmbeddedContainer(String startType,
			String[] endTypes, String endTagName) {
		// the context of the region being added to the embedded container
		internalContext = startType;
		// keep track of where this container began; to provide relative indeces
		// for the regions
		int containerStart = yychar;
		boolean notFinished = true;
		// keep track of where we seem to be so that the endTagName can be
		// checked
		boolean isInEndTag = false;
		boolean isInFirstTag = true;
		// create the embedded container and setup its "type"
		if (fEmbeddedContainer == null) {
			fEmbeddedContainer = new ContextRegionContainer();
			fEmbeddedContainer.setType(fEmbeddedHint);
			fEmbeddedContainer.setStart(containerStart);
			// TODO: parent region needs to be set .... but not sure where to
			// get it from
			// fEmbeddedContainer.setParent(parentRegion);
		}
		containerStart = fEmbeddedContainer.getStart();
		while (notFinished) {
			// add the region to the container
			if (internalContext != null && internalContext != PROXY_CONTEXT) {

				ITextRegion newToken;
				// if it is php content we extract the tokens
				if (internalContext == PHP_CONTENT) {
					newToken = bufferedTextRegion;
					bufferedTextRegion.adjustStart(-containerStart);
				} else {
					newToken = fRegionFactory.createToken(internalContext,
							yychar - containerStart, yylength(), yylength());
				}
				fEmbeddedContainer.getRegions().add(newToken);
				fEmbeddedContainer.setLength(fEmbeddedContainer.getLength()
						+ newToken.getLength());
				fEmbeddedContainer.setTextLength(fEmbeddedContainer
						.getTextLength() + newToken.getLength());
				// DW, 4/16/2003 token regions no longer have parents
				// newToken.setParent(fEmbeddedContainer);
			}
			try {
				// longscan determines whether to attempt a blockTagScan within
				// the embedded container
				boolean longscan = false;
				// save the tokenizer state in case of a block tag scan
				int previousState = yystate();
				String previousCurrentTagName = fCurrentTagName;
				int previousPostState = fEmbeddedPostState;
				String previousEmbeddedHint = fEmbeddedHint;
				// determine if a block tag scan is necessary
				if (internalContext == XML_TAG_NAME) {
					internalTagName = yytext();
					if (!isNestable(internalTagName)) {
						internalTagName = null;
						// snagged a tag name we shouldn't have
						fEmbeddedPostState = ST_ABORT_EMBEDDED;
						notFinished = false;
					}
				} else if (internalContext == XML_TAG_OPEN
						|| internalContext == XML_END_TAG_OPEN) {
					internalTagName = null;
				}
				// do upkeep for endTagName usage; must be here since the next
				// token could be the close
				if (internalContext == XML_END_TAG_OPEN) {
					isInEndTag = true;
				} else if (internalContext == XML_TAG_CLOSE) {
					isInFirstTag = isInEndTag = false;
				} else {
					ITextRegionList embeddedRegions = fEmbeddedContainer
							.getRegions();
					if (embeddedRegions.size() > 2
							&& (embeddedRegions.get(embeddedRegions.size() - 1))
									.getType() == XML_TAG_CLOSE
							&& (embeddedRegions.get(embeddedRegions.size() - 3))
									.getType() == XML_TAG_OPEN
							&& internalTagName != null) {
						if (containsTagName(internalTagName)) {
							longscan = true;
							yybegin(ST_BLOCK_TAG_SCAN);
						}
					}
				}
				if (longscan)
					fCurrentTagName = internalTagName;
				// read the next region and context
				internalContext = primGetNextToken();
				if (longscan) {
					// Returning from a block tag scan requires restoring some
					// state variables
					// as well as handling the block region and setting up for
					// normal scanning
					// inside the embedded container

					ITextRegion newToken;
					// if it is php content we extract the tokens
					if (internalContext == PHP_CONTENT) {
						newToken = bufferedTextRegion;
						bufferedTextRegion.adjustStart(-containerStart);
					} else {
						newToken = fRegionFactory
								.createToken(internalContext, yychar
										- containerStart, yylength(),
										yylength());
					}

					fEmbeddedContainer.getRegions().add(newToken);
					fEmbeddedContainer.setLength(fEmbeddedContainer.getLength()
							+ newToken.getLength());
					fEmbeddedContainer.setTextLength(fEmbeddedContainer
							.getTextLength() + newToken.getLength());
					// DW, 4/16/2003 token regions no longer have parents
					// newToken.setParent(fEmbeddedContainer);
					longscan = false;
					fEmbeddedPostState = previousPostState;
					fEmbeddedHint = previousEmbeddedHint;
					fCurrentTagName = previousCurrentTagName;
					yybegin(previousState);
					internalContext = primGetNextToken();
				}
			} catch (IOException e) {
				// primGetNextToken() calls may throw an IOException
				// catch and do nothing since the isEOF check below
				// will properly exit if the input was too short
			} catch (Exception f) {
				// some other exception happened; never should
				Logger.logException(f);
			}
			boolean isEndingType = yystate() == ST_ABORT_EMBEDDED;
			if (!isEndingType) {
				// check for ending context
				if (endTagName == null) {
					for (int i = 0; i < endTypes.length; i++) {
						isEndingType = isEndingType
								|| (internalContext == endTypes[i]);
					}
				} else {
					isEndingType = ((isInEndTag && internalContext == XML_TAG_CLOSE) || (isInFirstTag && internalContext == XML_EMPTY_TAG_CLOSE))
							&& internalTagName != null
							&& internalTagName.equals(endTagName);
				}
			}
			ITextRegionList embeddedList = fEmbeddedContainer.getRegions();
			notFinished = notFinished
					&& ((!isEndingType)
							&& !isEOF()
							&& (endTagName != null || internalContext != UNDEFINED) && !(internalContext == PROXY_CONTEXT && (embeddedList
							.get(embeddedList.size() - 1)).getType() == UNDEFINED));
		}
		// finish adding the last context
		if (internalContext != null && internalContext != PROXY_CONTEXT) {
			ITextRegion newToken = fRegionFactory.createToken(internalContext,
					yychar - containerStart, yylength(), yylength());
			fEmbeddedContainer.getRegions().add(newToken);
			// DW, 4/16/2003 token regions no longer have parents
			// newToken.setParent(fEmbeddedContainer);
			fEmbeddedContainer.setLength(yychar - containerStart + yylength());
			fEmbeddedContainer.setTextLength(yychar - containerStart
					+ yylength());
		}
		yybegin(fEmbeddedPostState);
	}

	/**
	 * user method
	 */
	private boolean isNestable(String tagName) {
		return false; // true is for jsp
	}

	/**
	 * user method
	 * 
	 * A generic lookahead-like operation
	 */
	private final String doBlockScan(String target, String targetContext,
			int immediateFallbackState) throws IOException {
		return doScan(target, false, targetContext, immediateFallbackState,
				immediateFallbackState);
	}

	/**
	 * user method does a lookahead for the current tag name
	 */
	private final String doBlockTagScan() throws IOException {
		fIsCaseSensitiveBlocking = getBlockMarkerCaseSensitivity();
		return doScan("</" + fCurrentTagName, true,
				getBlockMarkerContext(fCurrentTagName), YYINITIAL, YYINITIAL);
	}

	private IProject project;

	public void setProject(IProject project) {
		this.project = project;
		this.phpVersion = ProjectOptions.getPhpVersion(project);
	}

	public void reset(java.io.Reader reader, char[] buffer, int[] parameters) {
		this.phpVersion = ProjectOptions.getPhpVersion(project);
		this.zzReader = reader;
		this.zzBuffer = buffer;
		this.zzMarkedPos = parameters[0];
		this.zzPushbackPos = parameters[1];
		this.zzCurrentPos = parameters[2];
		this.zzStartRead = parameters[3];
		this.zzEndRead = parameters[4];
		this.yyline = parameters[5];
		this.yychar = this.zzStartRead - this.zzPushbackPos;
	}

	public int[] getParamenters() {
		return new int[] { zzMarkedPos, zzPushbackPos, zzCurrentPos,
				zzStartRead, zzEndRead, yyline, zzLexicalState };
	}

	/**
	 * user method
	 * 
	 * Converts the raw context String returned by the primGetNextToken() method
	 * into a full ITextRegion by pulling in values for the current offset
	 * within the scanning text.
	 * 
	 * Returns null when EOF is encountered and attaches intermittently
	 * discovered whitespace onto the end of useful regions.
	 * 
	 * Note that this algorithm caches the token following the one being
	 * returned so that whitespace can be collapsed.
	 */
	public final ITextRegion getNextToken() throws IOException {
		fEmbeddedContainer = null;
		// load the starting non-whitespace token (assume that it is so)
		if (fShouldLoadBuffered) {
			if (fBufferedEmbeddedContainer != null) {
				ITextRegion container = fBufferedEmbeddedContainer;
				fBufferedEmbeddedContainer = null;
				fShouldLoadBuffered = false;
				return container;
			}
			context = fBufferedContext;
			text = fBufferedText;
			start = fBufferedStart;
			textLength = length = fBufferedLength;
			fShouldLoadBuffered = false;
		} else {
			context = primGetNextToken();
			if (context == PROXY_CONTEXT) {
				return fEmbeddedContainer;
			} else if (context == XML_TAG_OPEN) {
				fIsBlockingEnabled = true;
			} else if (context == XML_END_TAG_OPEN) {
				fIsBlockingEnabled = false;
			}
			text = yytext();
			if (context == XML_TAG_NAME) {
				if (containsTagName(zzBuffer, zzStartRead, zzMarkedPos
						- zzStartRead))
					fCurrentTagName = text;
				else
					fCurrentTagName = null;
			} else if (context == XML_TAG_OPEN) {
				fIsBlockingEnabled = true;
			} else if (context == XML_END_TAG_OPEN) {
				fIsBlockingEnabled = false;
			}
			start = yychar;
			textLength = length = yylength();
			if (zzAtEOF) {
				fTokenCount++;
				return null;
			}
		}

		// store the next token
		f_context = primGetNextToken();
		if (f_context == PROXY_CONTEXT) {
			fBufferedEmbeddedContainer = fEmbeddedContainer;
			fShouldLoadBuffered = true;
		} else if (f_context == XML_TAG_NAME) {
			if (containsTagName(zzBuffer, zzStartRead, zzMarkedPos
					- zzStartRead))
				fCurrentTagName = yytext();
			else
				fCurrentTagName = null;
		} else if (f_context == XML_TAG_OPEN) {
			fIsBlockingEnabled = true;
		} else if (f_context == XML_END_TAG_OPEN) {
			fIsBlockingEnabled = false;
		}
		fBufferedContext = f_context;
		fBufferedText = yytext();
		if (fBufferedContext == XML_TAG_NAME) {
			if (containsTagName(zzBuffer, zzStartRead, zzMarkedPos
					- zzStartRead))
				fCurrentTagName = fBufferedText;
			else
				fCurrentTagName = null;
		} else if (fBufferedContext == XML_TAG_OPEN) {
			fIsBlockingEnabled = true;
		} else if (fBufferedContext == XML_END_TAG_OPEN) {
			fIsBlockingEnabled = false;
		}
		fBufferedStart = yychar;
		fBufferedLength = yylength();
		if (fBufferedContext == WHITE_SPACE) {
			fShouldLoadBuffered = false;
			length += fBufferedLength;
		} else {
			fShouldLoadBuffered = true;
		}
		if (context == null) {
			// EOF
			if (Debug.debugTokenizer) {
				System.out.println(getClass().getName()
						+ " discovered " + fTokenCount + " tokens."); //$NON-NLS-2$//$NON-NLS-1$
			}
			return null;
		}
		fTokenCount++;

		// if it is php content we extract the tokens
		if (context == PHP_CONTENT) {
			return bufferedTextRegion;
		} else {
			return fRegionFactory.createToken(context, start, textLength,
					length, null, fCurrentTagName);
		}
	}

	/* user method */
	public PHPTokenizer() {
		super();
	}

	/* user method */
	public PHPTokenizer(char[] charArray) {
		this(new CharArrayReader(charArray));
	}

	/* user method */
	public void reset(char[] charArray) {
		reset(new CharArrayReader(charArray), 0);
	}

	/* user method */
	public void reset(char[] charArray, int newOffset) {
		reset(new CharArrayReader(charArray), newOffset);
	}

	/* user method */
	public void reset(java.io.InputStream in) {
		reset(new java.io.InputStreamReader(in), 0);
	}

	/* user method */
	public void reset(java.io.InputStream in, int newOffset) {
		reset(new java.io.InputStreamReader(in), newOffset);
	}

	/* user method */
	public void reset(java.io.Reader in) {
		reset(in, 0);
	}

	/**
	 * user method *
	 * 
	 * Reset internal counters and vars to "newly created" values, in the hopes
	 * that resetting a pre-existing tokenizer is faster than creating a new
	 * one.
	 * 
	 * This method contains code blocks that were essentially duplicated from
	 * the <em>generated</em> output of this specification before this method
	 * was added. Those code blocks were under the above copyright.
	 */
	public void reset(java.io.Reader in, int newOffset) {
		if (Debug.debugTokenizer) {
			System.out.println("resetting tokenizer");//$NON-NLS-1$
		}
		phpVersion = ProjectOptions.getPhpVersion(project);
		fOffset = newOffset;

		/* the input device */
		zzReader = in;

		/* the current state of the DFA */
		zzState = 0;

		/* the current lexical state */
		zzLexicalState = YYINITIAL;

		/*
		 * this buffer contains the current text to be matched and is the source
		 * of the yytext() string
		 */
		java.util.Arrays.fill(zzBuffer, (char) 0);

		/* the textposition at the last accepting state */
		zzMarkedPos = 0;

		/* the textposition at the last state to be included in yytext */
		zzPushbackPos = 0;

		/* the current text position in the buffer */
		zzCurrentPos = 0;

		/* startRead marks the beginning of the yytext() string in the buffer */
		zzStartRead = 0;

		/**
		 * endRead marks the last character in the buffer, that has been read
		 * from input
		 */
		zzEndRead = 0;

		/* number of newlines encountered up to the start of the matched text */
		yyline = 0;

		/* the number of characters up to the start of the matched text */
		yychar = 0;

		/* zzAtEOF == true <=> the scanner has returned a value for EOF */
		zzAtEOF = false;

		/* denotes if the user-EOF-code has already been executed */
		// yy_eof_done = false;

		/* user vars: */
		fLastInternalBlockStart = -1;

		fTokenCount = 0;

		fShouldLoadBuffered = false;
		fBufferedContext = null;
		fBufferedText = null;
		fBufferedStart = 1;
		fBufferedLength = 0;
		fStateStack = new IntStack();

		context = null;
		text = null;
		start = 0;
		textLength = 0;
		length = 0;
	}

	/**
	 * user method
	 * 
	 */
	public BlockTokenizer newInstance() {
		PHPTokenizer newInstance = new PHPTokenizer();
		// global tagmarkers can be shared; they have no state and
		// are never destroyed (e.g. 'release')
		for (int i = 0; i < fBlockMarkers.size(); i++) {
			BlockMarker blockMarker = (BlockMarker) fBlockMarkers.get(i);
			if (blockMarker.isGlobal())
				newInstance.addBlockMarker(blockMarker);
		}
		return newInstance;
	}

	/* user method */
	private final String scanXMLCommentText() throws IOException {
		// Scan for '-->' and return the text up to that point as
		// XML_COMMENT_TEXT unless the string occurs IMMEDIATELY, in which
		// case change to the ST_XML_COMMENT_END state and return the next
		// context as usual.
		return doScan("-->", true, false, XML_COMMENT_TEXT, ST_XML_COMMENT_END,
				ST_XML_COMMENT_END);
	}

	/**
	 * Creates a new scanner There is also a java.io.InputStream version of this
	 * constructor.
	 * 
	 * @param in
	 *            the java.io.Reader to read input from.
	 */
	public PHPTokenizer(java.io.Reader in) {
		this.zzReader = in;
	}

	/**
	 * Creates a new scanner. There is also java.io.Reader version of this
	 * constructor.
	 * 
	 * @param in
	 *            the java.io.Inputstream to read input from.
	 */
	public PHPTokenizer(java.io.InputStream in) {
		this(new java.io.InputStreamReader(in));
	}

	/**
	 * Unpacks the compressed character translation table.
	 * 
	 * @param packed
	 *            the packed character translation table
	 * @return the unpacked character translation table
	 */
	private static char[] zzUnpackCMap(String packed) {
		char[] map = new char[0x10000];
		int i = 0; /* index in packed string */
		int j = 0; /* index in unpacked array */
		while (i < 1372) {
			int count = packed.charAt(i++);
			char value = packed.charAt(i++);
			do
				map[j++] = value;
			while (--count > 0);
		}
		return map;
	}

	/**
	 * Refills the input buffer.
	 * 
	 * @return <code>false</code>, iff there was new input.
	 * 
	 * @exception java.io.IOException
	 *                if any I/O-Error occurs
	 */
	private boolean zzRefill() throws java.io.IOException {

		/* first: make room (if you can) */
		if (zzStartRead > 0) {
			System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead
					- zzStartRead);

			/* translate stored positions */
			zzEndRead -= zzStartRead;
			zzCurrentPos -= zzStartRead;
			zzMarkedPos -= zzStartRead;
			zzPushbackPos -= zzStartRead;
			zzStartRead = 0;
		}

		/* is the buffer big enough? */
		if (zzCurrentPos >= zzBuffer.length) {
			/* if not: blow it up */
			char newBuffer[] = new char[zzCurrentPos * 2];
			System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
			zzBuffer = newBuffer;
		}

		/* finally: fill the buffer with new input */
		int numRead = zzReader.read(zzBuffer, zzEndRead, zzBuffer.length
				- zzEndRead);

		if (numRead < 0) {
			return true;
		} else {
			zzEndRead += numRead;
			return false;
		}
	}

	/**
	 * Gets the next input character.
	 * 
	 * @return the next character of the input stream, EOF if the end of the
	 *         stream is reached.
	 * @exception IOException
	 *                if any I/O-Error occurs
	 */
	private int yy_advance() throws java.io.IOException {

		/* standard case */
		if (zzCurrentPos < zzEndRead)
			return zzBuffer[zzCurrentPos++];

		/* if the eof is reached, we don't need to work hard */
		if (zzAtEOF)
			return YYEOF;

		/* otherwise: need to refill the buffer */

		/* first: make room (if you can) */
		if (zzRefill()) {
			return YYEOF;
		}

		return zzBuffer[zzCurrentPos++];
	}

	/**
	 * Closes the input stream.
	 */
	public final void yyclose() throws java.io.IOException {
		zzAtEOF = true; /* indicate end of file */
		zzEndRead = zzStartRead; /* invalidate buffer */

		if (zzReader != null)
			zzReader.close();
	}

	/**
	 * Resets the scanner to read from a new input stream. Does not close the
	 * old reader.
	 * 
	 * All internal variables are reset, the old input stream <b>cannot</b> be
	 * reused (internal buffer is discarded and lost). Lexical state is set to
	 * <tt>ZZ_INITIAL</tt>.
	 * 
	 * @param reader
	 *            the new input stream
	 */
	public final void yyreset(java.io.Reader reader) {
		zzReader = reader;
		// zzAtBOL = true;
		zzAtEOF = false;
		zzEndRead = zzStartRead = 0;
		zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
		yyline = yychar = 0;
		zzLexicalState = YYINITIAL;
	}

	/**
	 * Returns the current lexical state.
	 */
	public final int yystate() {
		return zzLexicalState;
	}

	/**
	 * Enters a new lexical state
	 * 
	 * @param newState
	 *            the new lexical state
	 */
	public final void yybegin(int newState) {
		zzLexicalState = newState;
	}

	/**
	 * Returns the text matched by the current regular expression.
	 */
	public final String yytext() {
		return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);
	}

	/**
	 * Returns the character at position <tt>pos</tt> from the matched text.
	 * 
	 * It is equivalent to yytext().charAt(pos), but faster
	 * 
	 * @param pos
	 *            the position of the character to fetch. A value from 0 to
	 *            yylength()-1.
	 * 
	 * @return the character at position pos
	 */
	public final char yycharat(int pos) {
		return zzBuffer[zzStartRead + pos];
	}

	/**
	 * Returns the length of the matched text region.
	 */
	public final int yylength() {
		return zzMarkedPos - zzStartRead;
	}

	/**
	 * Reports an error that occured while scanning.
	 * 
	 * In a wellformed scanner (no or only correct usage of yypushback(int) and
	 * a match-all fallback rule) this method will only be called with things
	 * that "Can't Possibly Happen". If this method is called, something is
	 * seriously wrong (e.g. a JFlex bug producing a faulty scanner etc.).
	 * 
	 * Usual syntax/scanner level error handling should be done in error
	 * fallback rules.
	 * 
	 * @param errorCode
	 *            the code of the errormessage to display
	 */
	private void zzScanError(int errorCode) {
		String message;
		try {
			message = ZZ_ERROR_MSG[errorCode];
		} catch (ArrayIndexOutOfBoundsException e) {
			message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
		}

		Logger.log(Logger.ERROR, message);
		try {
			throw new Error(message);
		} catch (Error e) {
			// BC
		}
	}

	/**
	 * Pushes the specified amount of characters back into the input stream.
	 * 
	 * They will be read again by then next call of the scanning method
	 * 
	 * @param number
	 *            the number of characters to be read again. This number must
	 *            not be greater than yylength()!
	 */
	public void yypushback(int number) {
		if (number > yylength())
			zzScanError(ZZ_PUSHBACK_2BIG);

		zzMarkedPos -= number;
	}

	/**
	 * user method - skeleton.sed
	 */
	protected final boolean containsTagName(char[] markerTagName, int offset,
			int tagnameLength) {
		for (int j = 0; j < fBlockMarkers.size(); j++) {
			BlockMarker marker = (BlockMarker) fBlockMarkers.get(j);
			if (marker.getTagName().length() == tagnameLength) {
				boolean matchesSoFar = true;
				for (int i = 0; i < tagnameLength && matchesSoFar; i++) {
					if (marker.isCaseSensitive()) {
						if (marker.getTagName().charAt(i) != markerTagName[i
								+ offset])
							matchesSoFar = false;
					} else {
						if (Character
								.toLowerCase(marker.getTagName().charAt(i)) != Character
								.toLowerCase(markerTagName[i + offset]))
							matchesSoFar = false;
					}
				}
				if (matchesSoFar)
					return true;
			}
		}
		return false;
	}

	/**
	 * user method - skeleton.sed
	 * 
	 * Return ALL of the regions scannable within the remaining text Note: for
	 * verification use
	 */
	public final List getRegions() {
		List tokens = new ArrayList();
		ITextRegion region = null;
		try {
			region = getNextToken();
			while (region != null) {
				if (region != null) {
					tokens.add(region);
				}
				region = getNextToken();
			}
		} catch (StackOverflowError e) {
			Logger.logException(
					getClass().getName()
							+ ": input could not be tokenized correctly at position " + getOffset(), e);//$NON-NLS-1$
			throw e;
		} catch (Exception e) {
			// Since this is convenience method and NOT the recommended
			// way of getting tokens, many errors are simply hidden
			Logger.logException(
					"Exception not handled retrieving regions: " + e.getLocalizedMessage(), e);//$NON-NLS-1$
		}
		return tokens;
	}

	/**
	 * user method - skeleton.sed
	 */
	private final void dump(String s) {
		if (Debug.debugTokenizer) {
			System.out.println(s + " (" + yychar + "-" + //$NON-NLS-2$//$NON-NLS-1$
					(yylength() + yychar) + "):\'" + //$NON-NLS-1$
					StringUtils.escape(yytext()) + "\'");//$NON-NLS-1$
		}
	}

	/* user method - skeleton.sed */
	public final boolean isEOF() {
		return zzAtEOF;
	}

	/* user method - skeleton.sed */
	protected final boolean containsTagName(String markerTagName) {
		Iterator blocks = fBlockMarkers.iterator();
		while (blocks.hasNext()) {
			BlockMarker marker = (BlockMarker) blocks.next();
			if (marker.isCaseSensitive()) {
				if (marker.getTagName().equals(markerTagName))
					return true;
			} else {
				if (marker.getTagName().equalsIgnoreCase(markerTagName))
					return true;
			}
		}
		return false;
	}

	/**
	 * Contains user EOF-code, which will be executed exactly once, when the end
	 * of file is reached
	 */
	private void zzDoEOF() {
		if (!zzEOFDone) {
			zzEOFDone = true;
			// do nothing, this is the downstream parser's job

		}
	}

	/**
	 * Resumes scanning until the next regular expression is matched, the end of
	 * input is encountered or an I/O-Error occurs.
	 * 
	 * @return the next token
	 * @exception java.io.IOException
	 *                if any I/O-Error occurs
	 */
	public String primGetNextToken() throws java.io.IOException {
		int zzInput;
		int zzAction;

		// cached fields:
		int zzCurrentPosL;
		int zzMarkedPosL;
		int zzEndReadL = zzEndRead;
		char[] zzBufferL = zzBuffer;
		char[] zzCMapL = ZZ_CMAP;

		int[] zzTransL = ZZ_TRANS;
		int[] zzRowMapL = ZZ_ROWMAP;
		int[] zzAttrL = ZZ_ATTRIBUTE;

		while (true) {
			zzMarkedPosL = zzMarkedPos;

			yychar += zzMarkedPosL - zzStartRead;

			boolean zzR = false;
			for (zzCurrentPosL = zzStartRead; zzCurrentPosL < zzMarkedPosL; zzCurrentPosL++) {
				switch (zzBufferL[zzCurrentPosL]) {
				case '\u000B':
				case '\u000C':
				case '\u0085':
				case '\u2028':
				case '\u2029':
					yyline++;
					zzR = false;
					break;
				case '\r':
					yyline++;
					zzR = true;
					break;
				case '\n':
					if (zzR)
						zzR = false;
					else {
						yyline++;
					}
					break;
				default:
					zzR = false;
				}
			}

			if (zzR) {
				// peek one character ahead if it is \n (if we have counted one
				// line too much)
				boolean zzPeek;
				if (zzMarkedPosL < zzEndReadL)
					zzPeek = zzBufferL[zzMarkedPosL] == '\n';
				else if (zzAtEOF)
					zzPeek = false;
				else {
					boolean eof = zzRefill();
					zzEndReadL = zzEndRead;
					zzMarkedPosL = zzMarkedPos;
					zzBufferL = zzBuffer;
					if (eof)
						zzPeek = false;
					else
						zzPeek = zzBufferL[zzMarkedPosL] == '\n';
				}
				if (zzPeek)
					yyline--;
			}
			zzAction = -1;

			zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;

			zzState = zzLexicalState;

			zzForAction: {
				while (true) {

					if (zzCurrentPosL < zzEndReadL)
						zzInput = zzBufferL[zzCurrentPosL++];
					else if (zzAtEOF) {
						zzInput = YYEOF;
						break zzForAction;
					} else {
						// store back cached positions
						zzCurrentPos = zzCurrentPosL;
						zzMarkedPos = zzMarkedPosL;
						boolean eof = zzRefill();
						// get translated positions and possibly new buffer
						zzCurrentPosL = zzCurrentPos;
						zzMarkedPosL = zzMarkedPos;
						zzBufferL = zzBuffer;
						zzEndReadL = zzEndRead;
						if (eof) {
							zzInput = YYEOF;
							break zzForAction;
						} else {
							zzInput = zzBufferL[zzCurrentPosL++];
						}
					}
					int zzNext = zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];
					if (zzNext == -1)
						break zzForAction;
					zzState = zzNext;

					int zzAttributes = zzAttrL[zzState];
					if ((zzAttributes & 1) == 1) {
						zzAction = zzState;
						zzMarkedPosL = zzCurrentPosL;
						if ((zzAttributes & 8) == 8)
							break zzForAction;
					}

				}
			}

			// store back cached position
			zzMarkedPos = zzMarkedPosL;

			switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
			case 24: { // equals
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_XML_ATTRIBUTE_VALUE);
				return XML_TAG_ATTRIBUTE_EQUALS;
			}
			case 69:
				break;
			case 39: { // begin embedded region: " + fEmbeddedHint
				int incomingState = yystate();
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				// tag inside of JSP attribute value start
				yybegin(ST_XML_TAG_NAME);
				assembleEmbeddedContainer(XML_TAG_OPEN, new String[] {
						XML_TAG_CLOSE, XML_EMPTY_TAG_CLOSE });
				if (yystate() != ST_ABORT_EMBEDDED)
					yybegin(incomingState);
				return PROXY_CONTEXT;
			}
			case 70:
				break;
			case 61: {
				if (Debug.debugTokenizer)
					dump("DHTML processing instruction target");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_DHTML_ATTRIBUTE_NAME);
				return XML_TAG_NAME;
			}
			case 71:
				break;
			case 50: {
				String tagName = yytext().substring(1);
				// pushback to just after the opening bracket
				yypushback(yylength() - 1);
				/*
				 * If this tag can not be nested or we're already searching for
				 * an attribute name, equals, or value, return immediately.
				 */
				if (!isNestable(tagName)
						|| (!fStateStack.empty() && (fStateStack.peek() == ST_XML_ATTRIBUTE_NAME
								|| fStateStack.peek() == ST_XML_EQUALS || fStateStack
								.peek() == ST_XML_ATTRIBUTE_VALUE))) {
					yybegin(ST_XML_TAG_NAME);
					return XML_TAG_OPEN;
				}
				if (Debug.debugTokenizer)
					dump("tag in place of attr value");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				fStateStack.push(yystate());
				// embedded container should be looking for the name (again)
				// next
				yybegin(ST_XML_TAG_NAME);
				assembleEmbeddedTagSequence(XML_TAG_OPEN, tagName); // ?
				fStateStack.pop();
				yybegin(ST_XML_ATTRIBUTE_NAME);
				return PROXY_CONTEXT;
			}
			case 72:
				break;
			case 19: {
				if (Debug.debugTokenizer)
					dump("DHTML processing instruction attribute name");//$NON-NLS-1$
				yybegin(ST_DHTML_EQUALS);
				return XML_TAG_ATTRIBUTE_NAME;
			}
			case 73:
				break;
			case 38: {
				return XML_TAG_ATTRIBUTE_VALUE;
			}
			case 74:
				break;
			case 6: {
				if (Debug.debugTokenizer)
					dump("attlist contentspec");//$NON-NLS-1$
				return XML_ATTLIST_DECL_CONTENT;
			}
			case 75:
				break;
			case 5: {
				if (Debug.debugTokenizer)
					dump("elementdecl contentspec");//$NON-NLS-1$
				return XML_ELEMENT_DECL_CONTENT;
			}
			case 76:
				break;
			case 1: {
				if (Debug.debugTokenizer)
					dump("\nXML content");//$NON-NLS-1$
				return XML_CONTENT;
			}
			case 77:
				break;
			case 17: {
				if (Debug.debugTokenizer)
					dump("XML processing instruction attribute value");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_PI_ATTRIBUTE_NAME);
				return XML_TAG_ATTRIBUTE_VALUE;
			}
			case 78:
				break;
			case 33: {
				if (Debug.debugTokenizer)
					dump("elementdecl close");//$NON-NLS-1$
				if (Debug.debugTokenizer) {
					if (fStateStack.peek() != YYINITIAL)
						System.out.println("end embedded region");//$NON-NLS-1$
				}
				yybegin(fStateStack.pop());
				return XML_DECLARATION_CLOSE;
			}
			case 79:
				break;
			case 2: {
				if (Debug.debugTokenizer)
					dump("white space");//$NON-NLS-1$
				return WHITE_SPACE;
			}
			case 80:
				break;
			case 9: {
				if (Debug.debugTokenizer)
					dump("CDATA text");//$NON-NLS-1$
				fEmbeddedPostState = ST_CDATA_TEXT;
				fEmbeddedHint = XML_CDATA_TEXT;
				String blockContext = doBlockScan(
						"]]>", XML_CDATA_TEXT, ST_CDATA_END);//$NON-NLS-1$
				if (blockContext == XML_CDATA_TEXT)
					yybegin(ST_CDATA_END);
				return blockContext;
			}
			case 81:
				break;
			case 34: {
				if (Debug.debugTokenizer)
					dump("attlist name");//$NON-NLS-1$
				yybegin(ST_XML_ATTLIST_DECLARATION_CONTENT);
				return XML_ATTLIST_DECL_NAME;
			}
			case 82:
				break;
			case 12: {
				if (Debug.debugTokenizer)
					dump("processing instruction target");//$NON-NLS-1$
				fEmbeddedHint = XML_CONTENT;
				yybegin(ST_PI_WS);
				return XML_TAG_NAME;
			}
			case 83:
				break;
			case 62: {
				if (Debug.debugTokenizer)
					dump("doctype external id");//$NON-NLS-1$
				yybegin(ST_XML_DOCTYPE_ID_SYSTEM);
				return XML_DOCTYPE_EXTERNAL_ID_SYSTEM;
			}
			case 84:
				break;
			case 29: {
				if (Debug.debugTokenizer)
					dump("doctype type");//$NON-NLS-1$
				yybegin(ST_XML_DOCTYPE_EXTERNAL_ID);
				return XML_DOCTYPE_NAME;
			}
			case 85:
				break;
			case 65: {
				if (Debug.debugTokenizer)
					dump("attlist");//$NON-NLS-1$
				yybegin(ST_XML_ATTLIST_DECLARATION);
				return XML_ATTLIST_DECLARATION;
			}
			case 86:
				break;
			case 28: {
				if (Debug.debugTokenizer)
					dump("declaration end");//$NON-NLS-1$
				if (Debug.debugTokenizer) {
					if (fStateStack.peek() != YYINITIAL)
						System.out.println("end embedded region");//$NON-NLS-1$
				}
				yybegin(fStateStack.pop());
				return XML_DECLARATION_CLOSE;
			}
			case 87:
				break;
			case 45: {
				if (Debug.debugTokenizer)
					dump("processing instruction end");//$NON-NLS-1$
				fEmbeddedHint = UNDEFINED;
				yybegin(YYINITIAL);
				return XML_PI_CLOSE;
			}
			case 88:
				break;
			case 57: {
				if (Debug.debugTokenizer)
					dump("comment end");//$NON-NLS-1$
				fEmbeddedHint = UNDEFINED;
				yybegin(YYINITIAL);
				return XML_COMMENT_CLOSE;
			}
			case 89:
				break;
			case 42: { // end tag open
				fEmbeddedHint = XML_TAG_NAME;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_XML_TAG_NAME);
				return XML_END_TAG_OPEN;
			}
			case 90:
				break;
			case 30: {
				if (Debug.debugTokenizer)
					dump("doctype public reference");//$NON-NLS-1$
				yybegin(ST_XML_DOCTYPE_ID_SYSTEM);
				return XML_DOCTYPE_EXTERNAL_ID_PUBREF;
			}
			case 91:
				break;
			case 20: {
				if (Debug.debugTokenizer)
					dump("DHTML processing instruction '='");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_DHTML_ATTRIBUTE_VALUE);
				return XML_TAG_ATTRIBUTE_EQUALS;
			}
			case 92:
				break;
			case 21: { // tag close
				fEmbeddedHint = UNDEFINED;
				if (isBlockMarker()) {
					fEmbeddedHint = getBlockMarkerContext();
					fEmbeddedPostState = ST_BLOCK_TAG_SCAN;
					yybegin(ST_BLOCK_TAG_SCAN);
				} else
					yybegin(YYINITIAL);
				return XML_TAG_CLOSE;
			}
			case 93:
				break;
			case 27: { // begin embedded region: " + fEmbeddedHint
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_SQUOTED;
				yybegin(ST_XML_ATTRIBUTE_VALUE_SQUOTED);
				fStateStack.push(yystate());
				// JSP attribute value start - complex single quoted
				assembleEmbeddedContainer(XML_TAG_ATTRIBUTE_VALUE_SQUOTE,
						XML_TAG_ATTRIBUTE_VALUE_SQUOTE);
				fStateStack.pop();
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_ATTRIBUTE_NAME);
				return PROXY_CONTEXT;
			}
			case 94:
				break;
			case 68: {
				if (Debug.debugTokenizer)
					dump("XSL processing instruction target");//$NON-NLS-1$
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_PI_ATTRIBUTE_NAME);
				return XML_TAG_NAME;
			}
			case 95:
				break;
			case 15: {
				if (Debug.debugTokenizer)
					dump("XML processing instruction attribute name");//$NON-NLS-1$
				yybegin(ST_XML_PI_EQUALS);
				return XML_TAG_ATTRIBUTE_NAME;
			}
			case 96:
				break;
			case 52: {
				yybegin(fStateStack.pop());
				return PHP_CLOSE;
			}
			case 97:
				break;
			case 18: {
				if (Debug.debugTokenizer)
					dump("DHTML processing instruction end");//$NON-NLS-1$
				fEmbeddedHint = UNDEFINED;
				yybegin(YYINITIAL);
				return XML_PI_CLOSE;
			}
			case 98:
				break;
			case 26: {
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_DQUOTED;
				yybegin(ST_XML_ATTRIBUTE_VALUE_DQUOTED);
				fStateStack.push(yystate());
				assembleEmbeddedContainer(XML_TAG_ATTRIBUTE_VALUE_DQUOTE,
						XML_TAG_ATTRIBUTE_VALUE_DQUOTE);
				fStateStack.pop();
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_ATTRIBUTE_NAME);
				return PROXY_CONTEXT;
			}
			case 99:
				break;
			case 32: {
				if (Debug.debugTokenizer)
					dump("elementdecl name");//$NON-NLS-1$
				yybegin(ST_XML_ELEMENT_DECLARATION_CONTENT);
				return XML_ELEMENT_DECL_NAME;
			}
			case 100:
				break;
			case 56: {
				if (Debug.debugTokenizer)
					dump("CDATA end");//$NON-NLS-1$
				yybegin(fStateStack.pop());
				return XML_CDATA_CLOSE;
			}
			case 101:
				break;
			case 53: { // begin embedded region: " + fEmbeddedHint);//$NON-NLS-1$
				int incomingState = yystate();
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				// Php attribute value start - end tag
				yybegin(ST_XML_TAG_NAME);
				assembleEmbeddedContainer(XML_END_TAG_OPEN, new String[] {
						XML_TAG_CLOSE, XML_EMPTY_TAG_CLOSE });
				if (yystate() != ST_ABORT_EMBEDDED)
					yybegin(incomingState);
				return PROXY_CONTEXT;
			}
			case 102:
				break;
			case 25: { // attr value
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_ATTRIBUTE_NAME);
				return XML_TAG_ATTRIBUTE_VALUE;
			}
			case 103:
				break;
			case 22: {
				if (Debug.debugTokenizer)
					dump("tag name");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_ATTRIBUTE_NAME);
				return XML_TAG_NAME;
			}
			case 104:
				break;
			case 8: {
				if (Debug.debugTokenizer)
					System.out
							.println("!!!unexpected!!!: \"" + yytext() + "\":" + //$NON-NLS-2$//$NON-NLS-1$
									yychar + "-" + (yychar + yylength()));//$NON-NLS-1$
				return UNDEFINED;
			}
			case 105:
				break;
			case 16: {
				if (Debug.debugTokenizer)
					dump("XML processing instruction '='");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_XML_PI_ATTRIBUTE_VALUE);
				return XML_TAG_ATTRIBUTE_EQUALS;
			}
			case 106:
				break;
			case 41: {
				return XML_TAG_ATTRIBUTE_VALUE_DQUOTE;
			}
			case 107:
				break;
			case 51: {
				return XML_DOCTYPE_INTERNAL_SUBSET;
			}
			case 108:
				break;
			case 67: {
				if (Debug.debugTokenizer)
					dump("\nCDATA start");//$NON-NLS-1$
				fStateStack.push(yystate());
				yybegin(ST_CDATA_TEXT);
				return XML_CDATA_OPEN;
			}
			case 109:
				break;
			case 54: {
				if (Debug.debugTokenizer)
					dump("\nEntityRef");//$NON-NLS-1$
				return XML_ENTITY_REFERENCE;
			}
			case 110:
				break;
			case 47: {
				if (Debug.debugTokenizer)
					dump("XML processing instruction end");//$NON-NLS-1$
				fEmbeddedHint = UNDEFINED;
				yybegin(YYINITIAL);
				return XML_PI_CLOSE;
			}
			case 111:
				break;
			case 37: {
				return doScanEndPhp(
						ProjectOptions.isSupportingAspTags(project),
						PHP_CONTENT, ST_PHP_CONTENT, ST_PHP_CONTENT);
			}
			case 112:
				break;
			case 40: {
				return XML_TAG_ATTRIBUTE_VALUE_SQUOTE;
			}
			case 113:
				break;
			case 55: {
				if (Debug.debugTokenizer)
					dump("\nPEReference");//$NON-NLS-1$
				return XML_PE_REFERENCE;
			}
			case 114:
				break;
			case 64: {
				if (Debug.debugTokenizer)
					dump("doctype");//$NON-NLS-1$
				yybegin(ST_XML_DOCTYPE_DECLARATION);
				return XML_DOCTYPE_DECLARATION;
			}
			case 115:
				break;
			case 14: { // block scan until close is found
				return doScan("?>", false, false, XML_PI_CONTENT,
						ST_XML_PI_TAG_CLOSE, ST_XML_PI_TAG_CLOSE);
			}
			case 116:
				break;
			case 13: {
				yybegin(ST_PI_CONTENT);
				return WHITE_SPACE;
			}
			case 117:
				break;
			case 36: {
				return doBlockTagScan();
			}
			case 118:
				break;
			case 10: {
				if (Debug.debugTokenizer)
					dump("LINE FEED");//$NON-NLS-1$
				return WHITE_SPACE;
			}
			case 119:
				break;
			case 23: { // attr name
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_XML_EQUALS);
				return XML_TAG_ATTRIBUTE_NAME;
			}
			case 120:
				break;
			case 58: {
				if (Debug.debugTokenizer)
					dump("XML processing instruction target");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_XML_PI_ATTRIBUTE_NAME);
				return XML_TAG_NAME;
			}
			case 121:
				break;
			case 7: {
				if (Debug.debugTokenizer)
					dump("\nstart tag open");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_NAME;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				yybegin(ST_XML_TAG_NAME);
				return XML_TAG_OPEN;
			}
			case 122:
				break;
			case 43: {
				if (Debug.debugTokenizer)
					dump("\nprocessing instruction start");//$NON-NLS-1$
				if ("<?".equals(yytext()) //$NON-NLS-1$
						&& !ProjectOptions.useShortTags(project)) {
					yybegin(ST_PI);
					return XML_PI_OPEN;
				} else if ("<?=".equals(yytext()) //$NON-NLS-1$
						&& !phpVersion.isGreaterThan(PHPVersion.PHP5_3)
						&& !ProjectOptions.useShortTags(project)) {
					yybegin(ST_PI);
					return XML_PI_OPEN;
				} else if ("<%".equals(yytext()) //$NON-NLS-1$ 
						&& !ProjectOptions.isSupportingAspTags(project)) {
					yypushback(1);
					yybegin(ST_XML_TAG_NAME);
					return XML_TAG_OPEN;
				} else {
					// removeing trailing whitespaces for the php open
					String phpStart = yytext();
					int i = phpStart.length() - 1;
					while (i >= 0
							&& Character.isWhitespace(phpStart.charAt(i--))) {
						yypushback(1);
					}
					fStateStack.push(yystate());// YYINITIAL
					if (fStateStack.peek() == YYINITIAL) {
						// the simple case, just a regular scriptlet out in
						// content
						yybegin(ST_PHP_CONTENT);
						return PHP_OPEN;
					} else {
						if (yystate() == ST_XML_ATTRIBUTE_VALUE_DQUOTED)
							fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_DQUOTED;
						else if (yystate() == ST_XML_ATTRIBUTE_VALUE_SQUOTED)
							fEmbeddedPostState = ST_XML_ATTRIBUTE_VALUE_SQUOTED;
						else if (yystate() == ST_CDATA_TEXT) {
							fEmbeddedPostState = ST_CDATA_TEXT;
							fEmbeddedHint = XML_CDATA_TEXT;
						}
						yybegin(ST_PHP_CONTENT);
						assembleEmbeddedContainer(PHP_OPEN, PHP_CLOSE);
						if (yystate() == ST_BLOCK_TAG_INTERNAL_SCAN) {
							yybegin(ST_BLOCK_TAG_SCAN);
							return BLOCK_TEXT;
						}
						// required help for successive embedded regions
						if (yystate() == ST_XML_TAG_NAME) {
							fEmbeddedHint = XML_TAG_NAME;
							fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
						} else if ((yystate() == ST_XML_ATTRIBUTE_NAME || yystate() == ST_XML_EQUALS)) {
							fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
							fEmbeddedPostState = ST_XML_EQUALS;
						} else if (yystate() == ST_XML_ATTRIBUTE_VALUE) {
							fEmbeddedHint = XML_TAG_ATTRIBUTE_VALUE;
							fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
						}
						return PROXY_CONTEXT;
					}
				}
			}
			case 123:
				break;
			case 59: {
				if (Debug.debugTokenizer)
					dump("\ncomment start");//$NON-NLS-1$
				fEmbeddedHint = XML_COMMENT_TEXT;
				fEmbeddedPostState = ST_XML_COMMENT;
				yybegin(ST_XML_COMMENT);
				return XML_COMMENT_OPEN;
			}
			case 124:
				break;
			case 63: {
				if (Debug.debugTokenizer)
					dump("doctype external id");//$NON-NLS-1$
				yybegin(ST_XML_DOCTYPE_ID_PUBLIC);
				return XML_DOCTYPE_EXTERNAL_ID_PUBLIC;
			}
			case 125:
				break;
			case 48: {
				yybegin(YYINITIAL);
				fEmbeddedHint = UNDEFINED;
				// empty tag close
				return XML_EMPTY_TAG_CLOSE;
			}
			case 126:
				break;
			case 35: {
				if (Debug.debugTokenizer)
					dump("attlist close");//$NON-NLS-1$
				if (Debug.debugTokenizer) {
					if (fStateStack.peek() != YYINITIAL)
						System.out.println("end embedded region");//$NON-NLS-1$
				}
				yybegin(fStateStack.pop());
				return XML_DECLARATION_CLOSE;
			}
			case 127:
				break;
			case 4: { // inappropriate tag name
				if (!fStateStack.empty()
						&& (fStateStack.peek() == ST_XML_ATTRIBUTE_VALUE_SQUOTED || fStateStack
								.peek() == ST_XML_ATTRIBUTE_VALUE_DQUOTED)) {
					yybegin(ST_ABORT_EMBEDDED);
					yypushback(yylength() - 1);
					return XML_TAG_ATTRIBUTE_VALUE;
				}
				yybegin(YYINITIAL);
				return XML_CONTENT;
			}
			case 128:
				break;
			case 60: {
				if (Debug.debugTokenizer)
					dump("\nCharRef");//$NON-NLS-1$
				return XML_CHAR_REFERENCE;
			}
			case 129:
				break;
			case 46: { // ended with nothing inside
				fEmbeddedHint = UNDEFINED;
				yybegin(YYINITIAL);
				return XML_PI_CLOSE;
			}
			case 130:
				break;
			case 44: {
				fStateStack.push(yystate());
				if (Debug.debugTokenizer)
					dump("\ndeclaration start");//$NON-NLS-1$
				yybegin(ST_XML_DECLARATION);
				return XML_DECLARATION_OPEN;
			}
			case 131:
				break;
			case 66: {
				if (Debug.debugTokenizer)
					dump("element");//$NON-NLS-1$
				yybegin(ST_XML_ELEMENT_DECLARATION);
				return XML_ELEMENT_DECLARATION;
			}
			case 132:
				break;
			case 49: {
				String tagName = yytext().substring(1);
				// pushback to just after the opening bracket
				yypushback(yylength() - 1);
				/*
				 * If this tag can not be nested or we're already searching for
				 * an attribute name, equals, or value, return immediately.
				 */
				if (!isNestable(tagName)
						|| (!fStateStack.empty() && (fStateStack.peek() == ST_XML_ATTRIBUTE_NAME
								|| fStateStack.peek() == ST_XML_EQUALS || fStateStack
								.peek() == ST_XML_ATTRIBUTE_VALUE))) {
					yybegin(ST_XML_TAG_NAME);
					return XML_TAG_OPEN;
				}
				if (Debug.debugTokenizer)
					dump("tag in place of attr name");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_ATTRIBUTE_NAME;
				fStateStack.push(yystate());
				// embedded container should be looking for the name (again)
				// next
				yybegin(ST_XML_TAG_NAME);
				assembleEmbeddedTagSequence(XML_TAG_OPEN, tagName); // ?
				fStateStack.pop();
				yybegin(ST_XML_EQUALS);
				return PROXY_CONTEXT;
			}
			case 133:
				break;
			case 31: {
				if (Debug.debugTokenizer)
					dump("doctype system reference");//$NON-NLS-1$
				yybegin(ST_XML_DECLARATION_CLOSE);
				return XML_DOCTYPE_EXTERNAL_ID_SYSREF;
			}
			case 134:
				break;
			case 11: {
				if (Debug.debugTokenizer)
					dump("comment content");//$NON-NLS-1$
				return scanXMLCommentText();
			}
			case 135:
				break;
			case 3: {
				if (Debug.debugTokenizer)
					dump("DHTML processing instruction attribute value");//$NON-NLS-1$
				fEmbeddedHint = XML_TAG_ATTRIBUTE_NAME;
				fEmbeddedPostState = ST_XML_EQUALS;
				yybegin(ST_DHTML_ATTRIBUTE_NAME);
				return XML_TAG_ATTRIBUTE_VALUE;
			}
			case 136:
				break;
			default:
				if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
					zzAtEOF = true;
					zzDoEOF();
					return null;
				} else {
					zzScanError(ZZ_NO_MATCH);
				}
			}
		}
	}

}
